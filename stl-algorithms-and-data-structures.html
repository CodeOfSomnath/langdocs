<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-27T17:15:22.9869246"><meta name="build-number" content="${buildNumber}">       <title>STL Algorithms and Data Structures | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-non-modifying-sequence-operations","level":0,"title":"2. Non-modifying Sequence Operations","anchor":"#2-non-modifying-sequence-operations"},{"id":"3-modifying-sequence-operations","level":0,"title":"3. Modifying Sequence Operations","anchor":"#3-modifying-sequence-operations"},{"id":"4-sorting-and-searching-operations","level":0,"title":"4. Sorting and Searching Operations","anchor":"#4-sorting-and-searching-operations"},{"id":"5-numeric-operations","level":0,"title":"5. Numeric Operations","anchor":"#5-numeric-operations"},{"id":"6-containers","level":0,"title":"6. Containers","anchor":"#6-containers"},{"id":"7-iterators","level":0,"title":"7. Iterators","anchor":"#7-iterators"},{"id":"8-allocators","level":0,"title":"8. Allocators","anchor":"#8-allocators"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="STL Algorithms and Data Structures | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="stl-algorithms-and-data-structures.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="STL Algorithms and Data Structures | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "stl-algorithms-and-data-structures.html#webpage", "url": "stl-algorithms-and-data-structures.html", "name": "STL Algorithms and Data Structures | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="STL-Algorithms-and-Data-Structures" data-main-title="STL Algorithms and Data Structures" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Cpp-Language.md|Cpp Language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="STL-Algorithms-and-Data-Structures"   id="STL-Algorithms-and-Data-Structures.md">STL Algorithms and Data Structures</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><p id="c60a7d94_3">The C++ Standard Template Library (STL) provides a collection of generic algorithms and data structures that are widely used in C++ programming. These components are implemented as templates, allowing them to work with different data types. Here's an overview of some key categories of STL algorithms and data structures:</p><section class="chapter"><h3 id="stl-algorithms" data-toc="stl-algorithms"   >STL Algorithms:</h3><ol class="list _decimal" id="c60a7d94_4" type="1"><li class="list__item" id="c60a7d94_5"><p id="c60a7d94_6"><span class="control" id="c60a7d94_7">Non-modifying Sequence Operations:</span></p><ul class="list _ul" id="c60a7d94_8"><li class="list__item" id="c60a7d94_9"><p><span class="control" id="c60a7d94_10"><code class="code" id="c60a7d94_11">std::for_each</code></span>: Applies a function to each element in a range.</p></li><li class="list__item" id="c60a7d94_12"><p><span class="control" id="c60a7d94_13"><code class="code" id="c60a7d94_14">std::count</code></span>: Counts the occurrences of a value in a range.</p></li><li class="list__item" id="c60a7d94_15"><p><span class="control" id="c60a7d94_16"><code class="code" id="c60a7d94_17">std::find</code></span>: Finds the first occurrence of a value in a range.</p></li><li class="list__item" id="c60a7d94_18"><p><span class="control" id="c60a7d94_19"><code class="code" id="c60a7d94_20">std::all_of</code>, <code class="code" id="c60a7d94_21">std::any_of</code>, <code class="code" id="c60a7d94_22">std::none_of</code></span>: Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul></li><li class="list__item" id="c60a7d94_23"><p id="c60a7d94_24"><span class="control" id="c60a7d94_25">Modifying Sequence Operations:</span></p><ul class="list _ul" id="c60a7d94_26"><li class="list__item" id="c60a7d94_27"><p><span class="control" id="c60a7d94_28"><code class="code" id="c60a7d94_29">std::copy</code></span>: Copies elements from one range to another.</p></li><li class="list__item" id="c60a7d94_30"><p><span class="control" id="c60a7d94_31"><code class="code" id="c60a7d94_32">std::transform</code></span>: Applies a function to each element in a range and stores the result in another range.</p></li><li class="list__item" id="c60a7d94_33"><p><span class="control" id="c60a7d94_34"><code class="code" id="c60a7d94_35">std::remove</code>, <code class="code" id="c60a7d94_36">std::remove_if</code></span>: Removes elements from a range based on a condition.</p></li><li class="list__item" id="c60a7d94_37"><p><span class="control" id="c60a7d94_38"><code class="code" id="c60a7d94_39">std::replace</code>, <code class="code" id="c60a7d94_40">std::replace_if</code></span>: Replaces elements in a range with a specified value or based on a condition.</p></li></ul></li><li class="list__item" id="c60a7d94_41"><p id="c60a7d94_42"><span class="control" id="c60a7d94_43">Sorting and Searching Operations:</span></p><ul class="list _ul" id="c60a7d94_44"><li class="list__item" id="c60a7d94_45"><p><span class="control" id="c60a7d94_46"><code class="code" id="c60a7d94_47">std::sort</code></span>: Sorts elements in a range.</p></li><li class="list__item" id="c60a7d94_48"><p><span class="control" id="c60a7d94_49"><code class="code" id="c60a7d94_50">std::binary_search</code></span>: Performs binary search on a sorted range.</p></li><li class="list__item" id="c60a7d94_51"><p><span class="control" id="c60a7d94_52"><code class="code" id="c60a7d94_53">std::merge</code></span>: Merges two sorted ranges into a single sorted range.</p></li><li class="list__item" id="c60a7d94_54"><p><span class="control" id="c60a7d94_55"><code class="code" id="c60a7d94_56">std::lower_bound</code>, <code class="code" id="c60a7d94_57">std::upper_bound</code></span>: Find the lower/upper bound of a value in a sorted range.</p></li></ul></li><li class="list__item" id="c60a7d94_58"><p id="c60a7d94_59"><span class="control" id="c60a7d94_60">Numeric Operations:</span></p><ul class="list _ul" id="c60a7d94_61"><li class="list__item" id="c60a7d94_62"><p><span class="control" id="c60a7d94_63"><code class="code" id="c60a7d94_64">std::accumulate</code></span>: Computes the sum of elements in a range.</p></li><li class="list__item" id="c60a7d94_65"><p><span class="control" id="c60a7d94_66"><code class="code" id="c60a7d94_67">std::inner_product</code></span>: Computes the inner product of two ranges.</p></li><li class="list__item" id="c60a7d94_68"><p><span class="control" id="c60a7d94_69"><code class="code" id="c60a7d94_70">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p></li></ul></li></ol></section><section class="chapter"><h3 id="stl-data-structures" data-toc="stl-data-structures"   >STL Data Structures:</h3><ol class="list _decimal" id="c60a7d94_71" type="1"><li class="list__item" id="c60a7d94_72"><p id="c60a7d94_73"><span class="control" id="c60a7d94_74">Containers:</span></p><ul class="list _ul" id="c60a7d94_75"><li class="list__item" id="c60a7d94_76"><p><span class="control" id="c60a7d94_77"><code class="code" id="c60a7d94_78">std::vector</code></span>: Dynamic array.</p></li><li class="list__item" id="c60a7d94_79"><p><span class="control" id="c60a7d94_80"><code class="code" id="c60a7d94_81">std::list</code></span>: Doubly-linked list.</p></li><li class="list__item" id="c60a7d94_82"><p><span class="control" id="c60a7d94_83"><code class="code" id="c60a7d94_84">std::deque</code></span>: Double-ended queue.</p></li><li class="list__item" id="c60a7d94_85"><p><span class="control" id="c60a7d94_86"><code class="code" id="c60a7d94_87">std::queue</code></span>: FIFO queue (adapter).</p></li><li class="list__item" id="c60a7d94_88"><p><span class="control" id="c60a7d94_89"><code class="code" id="c60a7d94_90">std::stack</code></span>: LIFO stack (adapter).</p></li><li class="list__item" id="c60a7d94_91"><p><span class="control" id="c60a7d94_92"><code class="code" id="c60a7d94_93">std::set</code></span>, <span class="control" id="c60a7d94_94"><code class="code" id="c60a7d94_95">std::multiset</code></span>: Sorted associative containers (sets).</p></li><li class="list__item" id="c60a7d94_96"><p><span class="control" id="c60a7d94_97"><code class="code" id="c60a7d94_98">std::map</code></span>, <span class="control" id="c60a7d94_99"><code class="code" id="c60a7d94_100">std::multimap</code></span>: Sorted associative containers (maps).</p></li><li class="list__item" id="c60a7d94_101"><p><span class="control" id="c60a7d94_102"><code class="code" id="c60a7d94_103">std::unordered_set</code></span>, <span class="control" id="c60a7d94_104"><code class="code" id="c60a7d94_105">std::unordered_multiset</code></span>: Unordered associative containers (unordered sets).</p></li><li class="list__item" id="c60a7d94_106"><p><span class="control" id="c60a7d94_107"><code class="code" id="c60a7d94_108">std::unordered_map</code></span>, <span class="control" id="c60a7d94_109"><code class="code" id="c60a7d94_110">std::unordered_multimap</code></span>: Unordered associative containers (unordered maps).</p></li></ul></li><li class="list__item" id="c60a7d94_111"><p id="c60a7d94_112"><span class="control" id="c60a7d94_113">Iterators:</span></p><ul class="list _ul" id="c60a7d94_114"><li class="list__item" id="c60a7d94_115"><p><span class="control" id="c60a7d94_116">Input Iterators</span>: Read-only access, single-pass.</p></li><li class="list__item" id="c60a7d94_117"><p><span class="control" id="c60a7d94_118">Output Iterators</span>: Write-only access, single-pass.</p></li><li class="list__item" id="c60a7d94_119"><p><span class="control" id="c60a7d94_120">Forward Iterators</span>: Read/write access, multiple-pass.</p></li><li class="list__item" id="c60a7d94_121"><p><span class="control" id="c60a7d94_122">Bidirectional Iterators</span>: Read/write access, bidirectional movement.</p></li><li class="list__item" id="c60a7d94_123"><p><span class="control" id="c60a7d94_124">Random Access Iterators</span>: Read/write access, random movement.</p></li></ul></li><li class="list__item" id="c60a7d94_125"><p id="c60a7d94_126"><span class="control" id="c60a7d94_127">Allocators:</span></p><ul class="list _ul" id="c60a7d94_128"><li class="list__item" id="c60a7d94_129"><p><span class="control" id="c60a7d94_130"><code class="code" id="c60a7d94_131">std::allocator</code></span>: Default allocator.</p></li><li class="list__item" id="c60a7d94_132"><p>Custom allocators can be used for memory management in containers.</p></li></ul></li></ol><p id="c60a7d94_133">These are just some examples, and there are many more algorithms and data structures in the STL. Understanding these components is crucial for efficient and expressive C++ programming.</p></section></section><section class="chapter"><h2 id="2-non-modifying-sequence-operations" data-toc="2-non-modifying-sequence-operations"   >2. Non-modifying Sequence Operations</h2><p id="c60a7d94_134">Non-modifying sequence operations in the C++ Standard Template Library (STL) are algorithms that operate on sequences ( ranges) without modifying the elements in the sequence. Here are some common non-modifying sequence operations along with examples:</p><ol class="list _decimal" id="c60a7d94_135" type="1"><li class="list__item" id="c60a7d94_136"><p id="c60a7d94_137"><span class="control" id="c60a7d94_138"><code class="code" id="c60a7d94_139">std::for_each</code>:</span></p><ul class="list _ul" id="c60a7d94_140"><li class="list__item" id="c60a7d94_141"><p>Applies a given function to each element in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void printSquare(int x) {
    std::cout &lt;&lt; x * x &lt;&lt; &quot; &quot;;
}

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::for_each(numbers.begin(), numbers.end(), printSquare);

    // Output: 1 4 9 16 25
    return 0;
}
</div></li><li class="list__item" id="c60a7d94_143"><p id="c60a7d94_144"><span class="control" id="c60a7d94_145"><code class="code" id="c60a7d94_146">std::count</code>:</span></p><ul class="list _ul" id="c60a7d94_147"><li class="list__item" id="c60a7d94_148"><p>Counts the occurrences of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 2, 4, 2, 5};

    int countOfTwos = std::count(numbers.begin(), numbers.end(), 2);

    // Output: Count of 2: 3
    std::cout &lt;&lt; &quot;Count of 2: &quot; &lt;&lt; countOfTwos &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="c60a7d94_150"><p id="c60a7d94_151"><span class="control" id="c60a7d94_152"><code class="code" id="c60a7d94_153">std::find</code>:</span></p><ul class="list _ul" id="c60a7d94_154"><li class="list__item" id="c60a7d94_155"><p>Finds the first occurrence of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    auto it = std::find(numbers.begin(), numbers.end(), 3);

    if (it != numbers.end()) {
        // Output: 3 found at position 2
        std::cout &lt;&lt; *it &lt;&lt; &quot; found at position &quot; &lt;&lt; std::distance(numbers.begin(), it) &lt;&lt; std::endl;
    } else {
        // Output: 3 not found
        std::cout &lt;&lt; &quot;3 not found&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</div></li><li class="list__item" id="c60a7d94_157"><p id="c60a7d94_158"><span class="control" id="c60a7d94_159"><code class="code" id="c60a7d94_160">std::all_of</code>, <code class="code" id="c60a7d94_161">std::any_of</code>, <code class="code" id="c60a7d94_162">std::none_of</code>:</span></p><ul class="list _ul" id="c60a7d94_163"><li class="list__item" id="c60a7d94_164"><p>Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {2, 4, 6, 8, 10};

    // Output: All are even: 1
    std::cout &lt;&lt; &quot;All are even: &quot; &lt;&lt; std::all_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 == 0; }) &lt;&lt; std::endl;

    // Output: Any is odd: 0
    std::cout &lt;&lt; &quot;Any is odd: &quot; &lt;&lt; std::any_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    // Output: None is odd: 1
    std::cout &lt;&lt; &quot;None is odd: &quot; &lt;&lt; std::none_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="c60a7d94_166">These examples illustrate the usage of non-modifying sequence operations in the STL, providing various ways to interact with and analyze sequences without altering their content.</p></section><section class="chapter"><h2 id="3-modifying-sequence-operations" data-toc="3-modifying-sequence-operations"   >3. Modifying Sequence Operations</h2><p id="c60a7d94_167">Modifying Sequence Operations in C++ STL are a set of algorithms that perform modifications directly on the elements of a sequence (like arrays or containers) in a generic way. These algorithms can be used to manipulate the contents of a range or container. Here are some common modifying sequence operations along with examples:</p><section class="chapter"><h3 id="std-copy" data-toc="std-copy"   >std::copy:</h3><p id="c60a7d94_168">The <code class="code" id="c60a7d94_169">std::copy</code> algorithm is used to copy elements from one range to another.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; source = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; destination(source.size());

    // Copy elements from source to destination
    std::copy(source.begin(), source.end(), destination.begin());

    // Print the contents of the destination vector
    for (int num : destination) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-transform" data-toc="std-transform"   >std::transform:</h3><p id="c60a7d94_171">The <code class="code" id="c60a7d94_172">std::transform</code> algorithm applies a specified operation to each element in a range and stores the result in another range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; squared_numbers(numbers.size());

    // Square each element and store the result in squared_numbers
    std::transform(numbers.begin(), numbers.end(), squared_numbers.begin(),
                   [](int x) { return x * x; });

    // Print the squared numbers
    for (int num : squared_numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-remove-and-std-remove-if" data-toc="std-remove-and-std-remove-if"   >std::remove and std::remove_if:</h3><p id="c60a7d94_174">These algorithms are used to remove elements from a range based on a specified value or condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Remove all occurrences of the value 2
    auto new_end = std::remove(numbers.begin(), numbers.end(), 2);

    // Resize the container to the new size after removal
    numbers.resize(std::distance(numbers.begin(), new_end));

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-replace-and-std-replace-if" data-toc="std-replace-and-std-replace-if"   >std::replace and std::replace_if:</h3><p id="c60a7d94_176">These algorithms replace elements in a range with a specified value or based on a condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Replace all occurrences of the value 2 with 0
    std::replace(numbers.begin(), numbers.end(), 2, 0);

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div><p id="c60a7d94_178">These examples illustrate the use of modifying sequence operations in the C++ STL to manipulate the contents of sequences or containers.</p></section></section><section class="chapter"><h2 id="4-sorting-and-searching-operations" data-toc="4-sorting-and-searching-operations"   >4. Sorting and Searching Operations</h2><p id="c60a7d94_179">Sure, let's delve into Sorting and Searching Operations in C++ using the STL.</p><section class="chapter"><h3 id="sorting-operations" data-toc="sorting-operations"   >Sorting Operations:</h3><section class="chapter"><h4 id="std-sort" data-toc="std-sort"   >std::sort:</h4><p id="c60a7d94_180">This algorithm is used to sort elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 7};

    std::sort(numbers.begin(), numbers.end());

    // Output: 1 2 5 7 8
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-stable-sort" data-toc="std-stable-sort"   >std::stable_sort:</h4><p id="c60a7d94_182">Similar to <code class="code" id="c60a7d94_183">std::sort</code>, but maintains the relative order of equal elements.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;std::pair&lt;int, std::string&gt;&gt; data = {{5, &quot;five&quot;}, {2, &quot;two&quot;}, {8, &quot;eight&quot;}, {1, &quot;one&quot;}, {7, &quot;seven&quot;}};

    std::stable_sort(data.begin(), data.end(), [](const auto&amp; a, const auto&amp; b) {
        return a.first &lt; b.first;
    });

    // Output: (1, &quot;one&quot;) (2, &quot;two&quot;) (5, &quot;five&quot;) (7, &quot;seven&quot;) (8, &quot;eight&quot;)
    for (const auto&amp; pair : data) {
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\&quot;) &quot;;
    }

    return 0;
}
</div></section></section><section class="chapter"><h3 id="searching-operations" data-toc="searching-operations"   >Searching Operations:</h3><section class="chapter"><h4 id="std-binary-search" data-toc="std-binary-search"   >std::binary_search:</h4><p id="c60a7d94_185">Performs binary search on a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    bool found = std::binary_search(numbers.begin(), numbers.end(), 5);

    // Output: Found
    if (found) {
        std::cout &lt;&lt; &quot;Found\n&quot;;
    } else {
        std::cout &lt;&lt; &quot;Not Found\n&quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-lower-bound-and-std-upper-bound" data-toc="std-lower-bound-and-std-upper-bound"   >std::lower_bound and std::upper_bound:</h4><p id="c60a7d94_187">Find the lower/upper bound of a value in a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    auto lower = std::lower_bound(numbers.begin(), numbers.end(), 5);
    auto upper = std::upper_bound(numbers.begin(), numbers.end(), 5);

    // Output: Lower Bound: 5, Upper Bound: 7
    std::cout &lt;&lt; &quot;Lower Bound: &quot; &lt;&lt; *lower &lt;&lt; &quot;, Upper Bound: &quot; &lt;&lt; *upper &lt;&lt; std::endl;

    return 0;
}
</div><p id="c60a7d94_189">These examples demonstrate some common sorting and searching operations using the STL in C++. Feel free to experiment with different data types and adapt these examples to your specific use cases.</p></section></section></section><section class="chapter"><h2 id="5-numeric-operations" data-toc="5-numeric-operations"   >5. Numeric Operations</h2><p id="c60a7d94_190">Numeric operations in C++ involve various algorithms for performing computations on numerical data. The <code class="code" id="c60a7d94_191">&lt;numeric&gt;</code> header in the Standard Template Library (STL) provides several functions that are commonly used for such operations. Here are some key numeric operations along with examples:</p><ol class="list _decimal" id="c60a7d94_192" type="1"><li class="list__item" id="c60a7d94_193"><p id="c60a7d94_194"><span class="control" id="c60a7d94_195"><code class="code" id="c60a7d94_196">std::accumulate</code></span>: Computes the sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="c60a7d94_198"><p id="c60a7d94_199"><span class="control" id="c60a7d94_200"><code class="code" id="c60a7d94_201">std::inner_product</code></span>: Computes the inner product of two ranges.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; a = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; b = {2, 2, 2, 2, 2};

    int result = std::inner_product(a.begin(), a.end(), b.begin(), 0);

    std::cout &lt;&lt; &quot;Inner Product: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="c60a7d94_203"><p id="c60a7d94_204"><span class="control" id="c60a7d94_205"><code class="code" id="c60a7d94_206">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::vector&lt;int&gt; partial_sums(numbers.size());
    std::partial_sum(numbers.begin(), numbers.end(), partial_sums.begin());

    std::cout &lt;&lt; &quot;Partial Sums: &quot;;
    for (int value : partial_sums) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="c60a7d94_208">These examples demonstrate how to use <code class="code" id="c60a7d94_209">std::accumulate</code>, <code class="code" id="c60a7d94_210">std::inner_product</code>, and <code class="code" id="c60a7d94_211">std::partial_sum</code> to perform common numeric operations. The <code class="code" id="c60a7d94_212">&lt;numeric&gt;</code> header provides other functions as well, so it's worth exploring the documentation for additional functionality related to numeric computations in C++.</p></section><section class="chapter"><h2 id="6-containers" data-toc="6-containers"   >6. Containers</h2><p id="c60a7d94_213">In C++, containers are objects that hold other objects. They are a crucial part of the Standard Template Library (STL) and provide various ways to store and organize data efficiently. Here are some commonly used containers in C++ along with examples:</p><section class="chapter"><h3 id="1-std-vector" data-toc="1-std-vector"   >1. std::vector</h3><ul class="list _ul" id="c60a7d94_214"><li class="list__item" id="c60a7d94_215"><p id="c60a7d94_216">Dynamic array that can resize itself.</p></li><li class="list__item" id="c60a7d94_217"><p id="c60a7d94_218">Elements are stored in contiguous memory.</p><div class="code-block" data-lang="cpp"         >
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="2-std-list" data-toc="2-std-list"   >2. std::list</h3><ul class="list _ul" id="c60a7d94_220"><li class="list__item" id="c60a7d94_221"><p id="c60a7d94_222">Doubly-linked list.</p></li><li class="list__item" id="c60a7d94_223"><p id="c60a7d94_224">Allows constant time insertions and deletions.</p><div class="code-block" data-lang="cpp"         >
#include &lt;list&gt;
#include &lt;iostream&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="3-std-deque" data-toc="3-std-deque"   >3. std::deque</h3><ul class="list _ul" id="c60a7d94_226"><li class="list__item" id="c60a7d94_227"><p id="c60a7d94_228">Double-ended queue.</p></li><li class="list__item" id="c60a7d94_229"><p id="c60a7d94_230">Similar to vectors but allows efficient insertion/removal at both ends.</p><div class="code-block" data-lang="cpp"         >
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    std::deque&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="4-std-set" data-toc="4-std-set"   >4. std::set</h3><ul class="list _ul" id="c60a7d94_232"><li class="list__item" id="c60a7d94_233"><p id="c60a7d94_234">Sorted associative container (set).</p></li><li class="list__item" id="c60a7d94_235"><p id="c60a7d94_236">Stores unique elements in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;set&gt;
#include &lt;iostream&gt;

int main() {
    std::set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="5-std-map" data-toc="5-std-map"   >5. std::map</h3><ul class="list _ul" id="c60a7d94_238"><li class="list__item" id="c60a7d94_239"><p id="c60a7d94_240">Sorted associative container (map).</p></li><li class="list__item" id="c60a7d94_241"><p id="c60a7d94_242">Stores key-value pairs in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;map&gt;
#include &lt;iostream&gt;

int main() {
    std::map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="6-std-unordered-set" data-toc="6-std-unordered-set"   >6. std::unordered_set</h3><ul class="list _ul" id="c60a7d94_244"><li class="list__item" id="c60a7d94_245"><p id="c60a7d94_246">Unordered associative container (unordered set).</p></li><li class="list__item" id="c60a7d94_247"><p id="c60a7d94_248">Stores unique elements in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_set&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="7-std-unordered-map" data-toc="7-std-unordered-map"   >7. std::unordered_map</h3><ul class="list _ul" id="c60a7d94_250"><li class="list__item" id="c60a7d94_251"><p id="c60a7d94_252">Unordered associative container (unordered map).</p></li><li class="list__item" id="c60a7d94_253"><p id="c60a7d94_254">Stores key-value pairs in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul><p id="c60a7d94_256">These are just a few examples, and C++ provides other containers and variations to suit different needs. The choice of a container depends on the specific requirements of your program, such as the type of operations you need to perform and the performance characteristics you're aiming for.</p></section></section><section class="chapter"><h2 id="7-iterators" data-toc="7-iterators"   >7. Iterators</h2><p id="c60a7d94_257">In C++, iterators are used to iterate over the elements of a container (like arrays, vectors, lists, etc.) in a sequential manner. Iterators act as a bridge between the algorithms and the containers, providing a way to access elements without exposing the underlying details of the container's implementation. There are different types of iterators, each with varying capabilities.</p><p id="c60a7d94_258">Here are the main types of iterators in C++:</p><section class="chapter"><h3 id="1-input-iterators" data-toc="1-input-iterators"   >1. Input Iterators:</h3><ul class="list _ul" id="c60a7d94_259"><li class="list__item" id="c60a7d94_260"><p>Allow sequential access to the elements of a container in a forward direction.</p></li><li class="list__item" id="c60a7d94_261"><p>Read-only access.</p></li><li class="list__item" id="c60a7d94_262"><p>Single-pass, meaning you can traverse the container only once.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using input iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="2-output-iterators" data-toc="2-output-iterators"   >2. Output Iterators:</h3><ul class="list _ul" id="c60a7d94_264"><li class="list__item" id="c60a7d94_265"><p>Allow sequential access to the elements of a container for writing.</p></li><li class="list__item" id="c60a7d94_266"><p>Write-only access.</p></li><li class="list__item" id="c60a7d94_267"><p>Single-pass.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers;

    // Example of using output iterators
    for (int i = 1; i &lt;= 5; ++i) {
        numbers.push_back(i);
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="3-forward-iterators" data-toc="3-forward-iterators"   >3. Forward Iterators:</h3><ul class="list _ul" id="c60a7d94_269"><li class="list__item" id="c60a7d94_270"><p>Allow both reading and writing of elements.</p></li><li class="list__item" id="c60a7d94_271"><p>Support multiple passes over the container.</p></li><li class="list__item" id="c60a7d94_272"><p>Can be used with algorithms that require bidirectional or random access iterators.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;forward_list&gt;

int main() {
    std::forward_list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using forward iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Modify the elements using the iterator
        *it *= 2;
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="4-bidirectional-iterators" data-toc="4-bidirectional-iterators"   >4. Bidirectional Iterators:</h3><ul class="list _ul" id="c60a7d94_274"><li class="list__item" id="c60a7d94_275"><p>Support both forward and backward movement.</p></li><li class="list__item" id="c60a7d94_276"><p>Used in algorithms that require backward traversal.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using bidirectional iterators
    auto it = numbers.end();
    while (it != numbers.begin()) {
        --it;
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="5-random-access-iterators" data-toc="5-random-access-iterators"   >5. Random Access Iterators:</h3><ul class="list _ul" id="c60a7d94_278"><li class="list__item" id="c60a7d94_279"><p>Support random access to elements (direct access by index).</p></li><li class="list__item" id="c60a7d94_280"><p>Provide efficient movement in both forward and backward directions.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using random access iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Access elements using iterator as if it were a pointer
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    // Accessing elements directly by index
    std::cout &lt;&lt; &quot;\nThird element: &quot; &lt;&lt; numbers[2];

    return 0;
}
</div><p id="c60a7d94_282">Understanding and using iterators is fundamental for working effectively with the C++ Standard Template Library and its algorithms.</p></section></section><section class="chapter"><h2 id="8-allocators" data-toc="8-allocators"   >8. Allocators</h2><p id="c60a7d94_283">In C++, allocators are objects responsible for allocating and deallocating memory for containers. They provide a level of abstraction between the container and the memory management system. The <code class="code" id="c60a7d94_284">std::allocator</code> is the default allocator provided by the C++ Standard Library, but custom allocators can be implemented to tailor memory management to specific needs.</p><p id="c60a7d94_285">Here's a brief explanation of allocators along with an example using <code class="code" id="c60a7d94_286">std::allocator</code>:</p><section class="chapter"><h3 id="std-allocator-example" data-toc="std-allocator-example"   >std::allocator Example:</h3><p id="c60a7d94_287">The <code class="code" id="c60a7d94_288">std::allocator</code> template class is a simple allocator that uses <code class="code" id="c60a7d94_289">new</code> and <code class="code" id="c60a7d94_290">delete</code> to allocate and deallocate memory. It is the default allocator for most C++ Standard Library containers.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt; // for std::allocator

int main() {
    // Example using std::allocator with std::vector
    std::allocator&lt;int&gt; myAllocator;

    // Allocate memory for an array of 5 integers
    int* data = myAllocator.allocate(5);

    // Initialize the allocated memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.construct(&amp;data[i], i + 1);
    }

    // Use the initialized data
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    // Deallocate the memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.destroy(&amp;data[i]);
    }
    myAllocator.deallocate(data, 5);

    return 0;
}
</div><p id="c60a7d94_292">In this example:</p><ul class="list _ul" id="c60a7d94_293"><li class="list__item" id="c60a7d94_294"><p><code class="code" id="c60a7d94_295">myAllocator.allocate(5)</code> allocates memory for an array of 5 integers.</p></li><li class="list__item" id="c60a7d94_296"><p><code class="code" id="c60a7d94_297">myAllocator.construct(&amp;data[i], i + 1)</code> initializes each element in the allocated memory.</p></li><li class="list__item" id="c60a7d94_298"><p><code class="code" id="c60a7d94_299">myAllocator.destroy(&amp;data[i])</code> is used to explicitly call the destructor for each element.</p></li><li class="list__item" id="c60a7d94_300"><p><code class="code" id="c60a7d94_301">myAllocator.deallocate(data, 5)</code> deallocates the memory.</p></li></ul></section><section class="chapter"><h3 id="custom-allocators" data-toc="custom-allocators"   >Custom Allocators:</h3><p id="c60a7d94_302">You can create custom allocators by implementing a class that adheres to the allocator interface. The allocator interface typically includes functions like <code class="code" id="c60a7d94_303">allocate</code>, <code class="code" id="c60a7d94_304">deallocate</code>, <code class="code" id="c60a7d94_305">construct</code>, and <code class="code" id="c60a7d94_306">destroy</code>.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
struct MyAllocator {
    using value_type = T;

    MyAllocator() = default;

    T* allocate(std::size_t n) {
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, std::size_t n) {
        ::operator delete(p);
    }

    template &lt;typename... Args&gt;
    void construct(T* p, Args&amp;&amp;... args) {
        new (p) T(std::forward&lt;Args&gt;(args)...);
    }

    void destroy(T* p) {
        p-&gt;~T();
    }
};

int main() {
    // Example using a custom allocator with std::vector
    std::vector&lt;int, MyAllocator&lt;int&gt;&gt; myVector({1, 2, 3, 4, 5});

    for (const auto&amp; value : myVector) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div><p id="c60a7d94_308">In this example, <code class="code" id="c60a7d94_309">MyAllocator</code> is a simple custom allocator that uses <code class="code" id="c60a7d94_310">operator new</code> and <code class="code" id="c60a7d94_311">operator delete</code> for memory management. The <code class="code" id="c60a7d94_312">std::vector</code> is then instantiated with this custom allocator.</p></section></section><div class="last-modified"> Last modified: 27 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="templates-and-template-metaprogramming.html">Templates and Template Metaprogramming</a>   <a class="navigation-links__next" href="string-type.html">String type</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>