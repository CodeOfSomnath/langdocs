<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-23T10:56:54.1703759"><meta name="build-number" content="${buildNumber}">       <title>STL Algorithms and Data Structures | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-non-modifying-sequence-operations","level":0,"title":"2. Non-modifying Sequence Operations","anchor":"#2-non-modifying-sequence-operations"},{"id":"3-modifying-sequence-operations","level":0,"title":"3. Modifying Sequence Operations","anchor":"#3-modifying-sequence-operations"},{"id":"4-sorting-and-searching-operations","level":0,"title":"4. Sorting and Searching Operations","anchor":"#4-sorting-and-searching-operations"},{"id":"5-numeric-operations","level":0,"title":"5. Numeric Operations","anchor":"#5-numeric-operations"},{"id":"6-containers","level":0,"title":"6. Containers","anchor":"#6-containers"},{"id":"7-iterators","level":0,"title":"7. Iterators","anchor":"#7-iterators"},{"id":"8-allocators","level":0,"title":"8. Allocators","anchor":"#8-allocators"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="STL Algorithms and Data Structures | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="stl-algorithms-and-data-structures.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="STL Algorithms and Data Structures | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "stl-algorithms-and-data-structures.html#webpage", "url": "stl-algorithms-and-data-structures.html", "name": "STL Algorithms and Data Structures | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="STL-Algorithms-and-Data-Structures" data-main-title="STL Algorithms and Data Structures" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Cpp-Language.md|Cpp Language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="STL-Algorithms-and-Data-Structures"   id="STL-Algorithms-and-Data-Structures.md">STL Algorithms and Data Structures</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><p id="951a1fd1_2337">The C++ Standard Template Library (STL) provides a collection of generic algorithms and data structures that are widely used in C++ programming. These components are implemented as templates, allowing them to work with different data types. Here's an overview of some key categories of STL algorithms and data structures:</p><section class="chapter"><h3 id="stl-algorithms" data-toc="stl-algorithms"   >STL Algorithms:</h3><ol class="list _decimal" id="951a1fd1_2338" type="1"><li class="list__item" id="951a1fd1_2339"><p id="951a1fd1_2340"><span class="control" id="951a1fd1_2341">Non-modifying Sequence Operations:</span></p><ul class="list _ul" id="951a1fd1_2342"><li class="list__item" id="951a1fd1_2343"><p><span class="control" id="951a1fd1_2344"><code class="code" id="951a1fd1_2345">std::for_each</code></span>: Applies a function to each element in a range.</p></li><li class="list__item" id="951a1fd1_2346"><p><span class="control" id="951a1fd1_2347"><code class="code" id="951a1fd1_2348">std::count</code></span>: Counts the occurrences of a value in a range.</p></li><li class="list__item" id="951a1fd1_2349"><p><span class="control" id="951a1fd1_2350"><code class="code" id="951a1fd1_2351">std::find</code></span>: Finds the first occurrence of a value in a range.</p></li><li class="list__item" id="951a1fd1_2352"><p><span class="control" id="951a1fd1_2353"><code class="code" id="951a1fd1_2354">std::all_of</code>, <code class="code" id="951a1fd1_2355">std::any_of</code>, <code class="code" id="951a1fd1_2356">std::none_of</code></span>: Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul></li><li class="list__item" id="951a1fd1_2357"><p id="951a1fd1_2358"><span class="control" id="951a1fd1_2359">Modifying Sequence Operations:</span></p><ul class="list _ul" id="951a1fd1_2360"><li class="list__item" id="951a1fd1_2361"><p><span class="control" id="951a1fd1_2362"><code class="code" id="951a1fd1_2363">std::copy</code></span>: Copies elements from one range to another.</p></li><li class="list__item" id="951a1fd1_2364"><p><span class="control" id="951a1fd1_2365"><code class="code" id="951a1fd1_2366">std::transform</code></span>: Applies a function to each element in a range and stores the result in another range.</p></li><li class="list__item" id="951a1fd1_2367"><p><span class="control" id="951a1fd1_2368"><code class="code" id="951a1fd1_2369">std::remove</code>, <code class="code" id="951a1fd1_2370">std::remove_if</code></span>: Removes elements from a range based on a condition.</p></li><li class="list__item" id="951a1fd1_2371"><p><span class="control" id="951a1fd1_2372"><code class="code" id="951a1fd1_2373">std::replace</code>, <code class="code" id="951a1fd1_2374">std::replace_if</code></span>: Replaces elements in a range with a specified value or based on a condition.</p></li></ul></li><li class="list__item" id="951a1fd1_2375"><p id="951a1fd1_2376"><span class="control" id="951a1fd1_2377">Sorting and Searching Operations:</span></p><ul class="list _ul" id="951a1fd1_2378"><li class="list__item" id="951a1fd1_2379"><p><span class="control" id="951a1fd1_2380"><code class="code" id="951a1fd1_2381">std::sort</code></span>: Sorts elements in a range.</p></li><li class="list__item" id="951a1fd1_2382"><p><span class="control" id="951a1fd1_2383"><code class="code" id="951a1fd1_2384">std::binary_search</code></span>: Performs binary search on a sorted range.</p></li><li class="list__item" id="951a1fd1_2385"><p><span class="control" id="951a1fd1_2386"><code class="code" id="951a1fd1_2387">std::merge</code></span>: Merges two sorted ranges into a single sorted range.</p></li><li class="list__item" id="951a1fd1_2388"><p><span class="control" id="951a1fd1_2389"><code class="code" id="951a1fd1_2390">std::lower_bound</code>, <code class="code" id="951a1fd1_2391">std::upper_bound</code></span>: Find the lower/upper bound of a value in a sorted range.</p></li></ul></li><li class="list__item" id="951a1fd1_2392"><p id="951a1fd1_2393"><span class="control" id="951a1fd1_2394">Numeric Operations:</span></p><ul class="list _ul" id="951a1fd1_2395"><li class="list__item" id="951a1fd1_2396"><p><span class="control" id="951a1fd1_2397"><code class="code" id="951a1fd1_2398">std::accumulate</code></span>: Computes the sum of elements in a range.</p></li><li class="list__item" id="951a1fd1_2399"><p><span class="control" id="951a1fd1_2400"><code class="code" id="951a1fd1_2401">std::inner_product</code></span>: Computes the inner product of two ranges.</p></li><li class="list__item" id="951a1fd1_2402"><p><span class="control" id="951a1fd1_2403"><code class="code" id="951a1fd1_2404">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p></li></ul></li></ol></section><section class="chapter"><h3 id="stl-data-structures" data-toc="stl-data-structures"   >STL Data Structures:</h3><ol class="list _decimal" id="951a1fd1_2405" type="1"><li class="list__item" id="951a1fd1_2406"><p id="951a1fd1_2407"><span class="control" id="951a1fd1_2408">Containers:</span></p><ul class="list _ul" id="951a1fd1_2409"><li class="list__item" id="951a1fd1_2410"><p><span class="control" id="951a1fd1_2411"><code class="code" id="951a1fd1_2412">std::vector</code></span>: Dynamic array.</p></li><li class="list__item" id="951a1fd1_2413"><p><span class="control" id="951a1fd1_2414"><code class="code" id="951a1fd1_2415">std::list</code></span>: Doubly-linked list.</p></li><li class="list__item" id="951a1fd1_2416"><p><span class="control" id="951a1fd1_2417"><code class="code" id="951a1fd1_2418">std::deque</code></span>: Double-ended queue.</p></li><li class="list__item" id="951a1fd1_2419"><p><span class="control" id="951a1fd1_2420"><code class="code" id="951a1fd1_2421">std::queue</code></span>: FIFO queue (adapter).</p></li><li class="list__item" id="951a1fd1_2422"><p><span class="control" id="951a1fd1_2423"><code class="code" id="951a1fd1_2424">std::stack</code></span>: LIFO stack (adapter).</p></li><li class="list__item" id="951a1fd1_2425"><p><span class="control" id="951a1fd1_2426"><code class="code" id="951a1fd1_2427">std::set</code></span>, <span class="control" id="951a1fd1_2428"><code class="code" id="951a1fd1_2429">std::multiset</code></span>: Sorted associative containers (sets).</p></li><li class="list__item" id="951a1fd1_2430"><p><span class="control" id="951a1fd1_2431"><code class="code" id="951a1fd1_2432">std::map</code></span>, <span class="control" id="951a1fd1_2433"><code class="code" id="951a1fd1_2434">std::multimap</code></span>: Sorted associative containers (maps).</p></li><li class="list__item" id="951a1fd1_2435"><p><span class="control" id="951a1fd1_2436"><code class="code" id="951a1fd1_2437">std::unordered_set</code></span>, <span class="control" id="951a1fd1_2438"><code class="code" id="951a1fd1_2439">std::unordered_multiset</code></span>: Unordered associative containers (unordered sets).</p></li><li class="list__item" id="951a1fd1_2440"><p><span class="control" id="951a1fd1_2441"><code class="code" id="951a1fd1_2442">std::unordered_map</code></span>, <span class="control" id="951a1fd1_2443"><code class="code" id="951a1fd1_2444">std::unordered_multimap</code></span>: Unordered associative containers (unordered maps).</p></li></ul></li><li class="list__item" id="951a1fd1_2445"><p id="951a1fd1_2446"><span class="control" id="951a1fd1_2447">Iterators:</span></p><ul class="list _ul" id="951a1fd1_2448"><li class="list__item" id="951a1fd1_2449"><p><span class="control" id="951a1fd1_2450">Input Iterators</span>: Read-only access, single-pass.</p></li><li class="list__item" id="951a1fd1_2451"><p><span class="control" id="951a1fd1_2452">Output Iterators</span>: Write-only access, single-pass.</p></li><li class="list__item" id="951a1fd1_2453"><p><span class="control" id="951a1fd1_2454">Forward Iterators</span>: Read/write access, multiple-pass.</p></li><li class="list__item" id="951a1fd1_2455"><p><span class="control" id="951a1fd1_2456">Bidirectional Iterators</span>: Read/write access, bidirectional movement.</p></li><li class="list__item" id="951a1fd1_2457"><p><span class="control" id="951a1fd1_2458">Random Access Iterators</span>: Read/write access, random movement.</p></li></ul></li><li class="list__item" id="951a1fd1_2459"><p id="951a1fd1_2460"><span class="control" id="951a1fd1_2461">Allocators:</span></p><ul class="list _ul" id="951a1fd1_2462"><li class="list__item" id="951a1fd1_2463"><p><span class="control" id="951a1fd1_2464"><code class="code" id="951a1fd1_2465">std::allocator</code></span>: Default allocator.</p></li><li class="list__item" id="951a1fd1_2466"><p>Custom allocators can be used for memory management in containers.</p></li></ul></li></ol><p id="951a1fd1_2467">These are just some examples, and there are many more algorithms and data structures in the STL. Understanding these components is crucial for efficient and expressive C++ programming.</p></section></section><section class="chapter"><h2 id="2-non-modifying-sequence-operations" data-toc="2-non-modifying-sequence-operations"   >2. Non-modifying Sequence Operations</h2><p id="951a1fd1_2468">Non-modifying sequence operations in the C++ Standard Template Library (STL) are algorithms that operate on sequences ( ranges) without modifying the elements in the sequence. Here are some common non-modifying sequence operations along with examples:</p><ol class="list _decimal" id="951a1fd1_2469" type="1"><li class="list__item" id="951a1fd1_2470"><p id="951a1fd1_2471"><span class="control" id="951a1fd1_2472"><code class="code" id="951a1fd1_2473">std::for_each</code>:</span></p><ul class="list _ul" id="951a1fd1_2474"><li class="list__item" id="951a1fd1_2475"><p>Applies a given function to each element in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void printSquare(int x) {
    std::cout &lt;&lt; x * x &lt;&lt; &quot; &quot;;
}

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::for_each(numbers.begin(), numbers.end(), printSquare);

    // Output: 1 4 9 16 25
    return 0;
}
</div></li><li class="list__item" id="951a1fd1_2477"><p id="951a1fd1_2478"><span class="control" id="951a1fd1_2479"><code class="code" id="951a1fd1_2480">std::count</code>:</span></p><ul class="list _ul" id="951a1fd1_2481"><li class="list__item" id="951a1fd1_2482"><p>Counts the occurrences of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 2, 4, 2, 5};

    int countOfTwos = std::count(numbers.begin(), numbers.end(), 2);

    // Output: Count of 2: 3
    std::cout &lt;&lt; &quot;Count of 2: &quot; &lt;&lt; countOfTwos &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="951a1fd1_2484"><p id="951a1fd1_2485"><span class="control" id="951a1fd1_2486"><code class="code" id="951a1fd1_2487">std::find</code>:</span></p><ul class="list _ul" id="951a1fd1_2488"><li class="list__item" id="951a1fd1_2489"><p>Finds the first occurrence of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    auto it = std::find(numbers.begin(), numbers.end(), 3);

    if (it != numbers.end()) {
        // Output: 3 found at position 2
        std::cout &lt;&lt; *it &lt;&lt; &quot; found at position &quot; &lt;&lt; std::distance(numbers.begin(), it) &lt;&lt; std::endl;
    } else {
        // Output: 3 not found
        std::cout &lt;&lt; &quot;3 not found&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</div></li><li class="list__item" id="951a1fd1_2491"><p id="951a1fd1_2492"><span class="control" id="951a1fd1_2493"><code class="code" id="951a1fd1_2494">std::all_of</code>, <code class="code" id="951a1fd1_2495">std::any_of</code>, <code class="code" id="951a1fd1_2496">std::none_of</code>:</span></p><ul class="list _ul" id="951a1fd1_2497"><li class="list__item" id="951a1fd1_2498"><p>Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {2, 4, 6, 8, 10};

    // Output: All are even: 1
    std::cout &lt;&lt; &quot;All are even: &quot; &lt;&lt; std::all_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 == 0; }) &lt;&lt; std::endl;

    // Output: Any is odd: 0
    std::cout &lt;&lt; &quot;Any is odd: &quot; &lt;&lt; std::any_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    // Output: None is odd: 1
    std::cout &lt;&lt; &quot;None is odd: &quot; &lt;&lt; std::none_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="951a1fd1_2500">These examples illustrate the usage of non-modifying sequence operations in the STL, providing various ways to interact with and analyze sequences without altering their content.</p></section><section class="chapter"><h2 id="3-modifying-sequence-operations" data-toc="3-modifying-sequence-operations"   >3. Modifying Sequence Operations</h2><p id="951a1fd1_2501">Modifying Sequence Operations in C++ STL are a set of algorithms that perform modifications directly on the elements of a sequence (like arrays or containers) in a generic way. These algorithms can be used to manipulate the contents of a range or container. Here are some common modifying sequence operations along with examples:</p><section class="chapter"><h3 id="std-copy" data-toc="std-copy"   >std::copy:</h3><p id="951a1fd1_2502">The <code class="code" id="951a1fd1_2503">std::copy</code> algorithm is used to copy elements from one range to another.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; source = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; destination(source.size());

    // Copy elements from source to destination
    std::copy(source.begin(), source.end(), destination.begin());

    // Print the contents of the destination vector
    for (int num : destination) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-transform" data-toc="std-transform"   >std::transform:</h3><p id="951a1fd1_2505">The <code class="code" id="951a1fd1_2506">std::transform</code> algorithm applies a specified operation to each element in a range and stores the result in another range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; squared_numbers(numbers.size());

    // Square each element and store the result in squared_numbers
    std::transform(numbers.begin(), numbers.end(), squared_numbers.begin(),
                   [](int x) { return x * x; });

    // Print the squared numbers
    for (int num : squared_numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-remove-and-std-remove-if" data-toc="std-remove-and-std-remove-if"   >std::remove and std::remove_if:</h3><p id="951a1fd1_2508">These algorithms are used to remove elements from a range based on a specified value or condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Remove all occurrences of the value 2
    auto new_end = std::remove(numbers.begin(), numbers.end(), 2);

    // Resize the container to the new size after removal
    numbers.resize(std::distance(numbers.begin(), new_end));

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-replace-and-std-replace-if" data-toc="std-replace-and-std-replace-if"   >std::replace and std::replace_if:</h3><p id="951a1fd1_2510">These algorithms replace elements in a range with a specified value or based on a condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Replace all occurrences of the value 2 with 0
    std::replace(numbers.begin(), numbers.end(), 2, 0);

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div><p id="951a1fd1_2512">These examples illustrate the use of modifying sequence operations in the C++ STL to manipulate the contents of sequences or containers.</p></section></section><section class="chapter"><h2 id="4-sorting-and-searching-operations" data-toc="4-sorting-and-searching-operations"   >4. Sorting and Searching Operations</h2><p id="951a1fd1_2513">Sure, let's delve into Sorting and Searching Operations in C++ using the STL.</p><section class="chapter"><h3 id="sorting-operations" data-toc="sorting-operations"   >Sorting Operations:</h3><section class="chapter"><h4 id="std-sort" data-toc="std-sort"   >std::sort:</h4><p id="951a1fd1_2514">This algorithm is used to sort elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 7};

    std::sort(numbers.begin(), numbers.end());

    // Output: 1 2 5 7 8
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-stable-sort" data-toc="std-stable-sort"   >std::stable_sort:</h4><p id="951a1fd1_2516">Similar to <code class="code" id="951a1fd1_2517">std::sort</code>, but maintains the relative order of equal elements.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;std::pair&lt;int, std::string&gt;&gt; data = {{5, &quot;five&quot;}, {2, &quot;two&quot;}, {8, &quot;eight&quot;}, {1, &quot;one&quot;}, {7, &quot;seven&quot;}};

    std::stable_sort(data.begin(), data.end(), [](const auto&amp; a, const auto&amp; b) {
        return a.first &lt; b.first;
    });

    // Output: (1, &quot;one&quot;) (2, &quot;two&quot;) (5, &quot;five&quot;) (7, &quot;seven&quot;) (8, &quot;eight&quot;)
    for (const auto&amp; pair : data) {
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\&quot;) &quot;;
    }

    return 0;
}
</div></section></section><section class="chapter"><h3 id="searching-operations" data-toc="searching-operations"   >Searching Operations:</h3><section class="chapter"><h4 id="std-binary-search" data-toc="std-binary-search"   >std::binary_search:</h4><p id="951a1fd1_2519">Performs binary search on a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    bool found = std::binary_search(numbers.begin(), numbers.end(), 5);

    // Output: Found
    if (found) {
        std::cout &lt;&lt; &quot;Found\n&quot;;
    } else {
        std::cout &lt;&lt; &quot;Not Found\n&quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-lower-bound-and-std-upper-bound" data-toc="std-lower-bound-and-std-upper-bound"   >std::lower_bound and std::upper_bound:</h4><p id="951a1fd1_2521">Find the lower/upper bound of a value in a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    auto lower = std::lower_bound(numbers.begin(), numbers.end(), 5);
    auto upper = std::upper_bound(numbers.begin(), numbers.end(), 5);

    // Output: Lower Bound: 5, Upper Bound: 7
    std::cout &lt;&lt; &quot;Lower Bound: &quot; &lt;&lt; *lower &lt;&lt; &quot;, Upper Bound: &quot; &lt;&lt; *upper &lt;&lt; std::endl;

    return 0;
}
</div><p id="951a1fd1_2523">These examples demonstrate some common sorting and searching operations using the STL in C++. Feel free to experiment with different data types and adapt these examples to your specific use cases.</p></section></section></section><section class="chapter"><h2 id="5-numeric-operations" data-toc="5-numeric-operations"   >5. Numeric Operations</h2><p id="951a1fd1_2524">Numeric operations in C++ involve various algorithms for performing computations on numerical data. The <code class="code" id="951a1fd1_2525">&lt;numeric&gt;</code> header in the Standard Template Library (STL) provides several functions that are commonly used for such operations. Here are some key numeric operations along with examples:</p><ol class="list _decimal" id="951a1fd1_2526" type="1"><li class="list__item" id="951a1fd1_2527"><p id="951a1fd1_2528"><span class="control" id="951a1fd1_2529"><code class="code" id="951a1fd1_2530">std::accumulate</code></span>: Computes the sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="951a1fd1_2532"><p id="951a1fd1_2533"><span class="control" id="951a1fd1_2534"><code class="code" id="951a1fd1_2535">std::inner_product</code></span>: Computes the inner product of two ranges.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; a = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; b = {2, 2, 2, 2, 2};

    int result = std::inner_product(a.begin(), a.end(), b.begin(), 0);

    std::cout &lt;&lt; &quot;Inner Product: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="951a1fd1_2537"><p id="951a1fd1_2538"><span class="control" id="951a1fd1_2539"><code class="code" id="951a1fd1_2540">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::vector&lt;int&gt; partial_sums(numbers.size());
    std::partial_sum(numbers.begin(), numbers.end(), partial_sums.begin());

    std::cout &lt;&lt; &quot;Partial Sums: &quot;;
    for (int value : partial_sums) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="951a1fd1_2542">These examples demonstrate how to use <code class="code" id="951a1fd1_2543">std::accumulate</code>, <code class="code" id="951a1fd1_2544">std::inner_product</code>, and <code class="code" id="951a1fd1_2545">std::partial_sum</code> to perform common numeric operations. The <code class="code" id="951a1fd1_2546">&lt;numeric&gt;</code> header provides other functions as well, so it's worth exploring the documentation for additional functionality related to numeric computations in C++.</p></section><section class="chapter"><h2 id="6-containers" data-toc="6-containers"   >6. Containers</h2><p id="951a1fd1_2547">In C++, containers are objects that hold other objects. They are a crucial part of the Standard Template Library (STL) and provide various ways to store and organize data efficiently. Here are some commonly used containers in C++ along with examples:</p><section class="chapter"><h3 id="1-std-vector" data-toc="1-std-vector"   >1. std::vector</h3><ul class="list _ul" id="951a1fd1_2548"><li class="list__item" id="951a1fd1_2549"><p id="951a1fd1_2550">Dynamic array that can resize itself.</p></li><li class="list__item" id="951a1fd1_2551"><p id="951a1fd1_2552">Elements are stored in contiguous memory.</p><div class="code-block" data-lang="cpp"         >
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="2-std-list" data-toc="2-std-list"   >2. std::list</h3><ul class="list _ul" id="951a1fd1_2554"><li class="list__item" id="951a1fd1_2555"><p id="951a1fd1_2556">Doubly-linked list.</p></li><li class="list__item" id="951a1fd1_2557"><p id="951a1fd1_2558">Allows constant time insertions and deletions.</p><div class="code-block" data-lang="cpp"         >
#include &lt;list&gt;
#include &lt;iostream&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="3-std-deque" data-toc="3-std-deque"   >3. std::deque</h3><ul class="list _ul" id="951a1fd1_2560"><li class="list__item" id="951a1fd1_2561"><p id="951a1fd1_2562">Double-ended queue.</p></li><li class="list__item" id="951a1fd1_2563"><p id="951a1fd1_2564">Similar to vectors but allows efficient insertion/removal at both ends.</p><div class="code-block" data-lang="cpp"         >
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    std::deque&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="4-std-set" data-toc="4-std-set"   >4. std::set</h3><ul class="list _ul" id="951a1fd1_2566"><li class="list__item" id="951a1fd1_2567"><p id="951a1fd1_2568">Sorted associative container (set).</p></li><li class="list__item" id="951a1fd1_2569"><p id="951a1fd1_2570">Stores unique elements in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;set&gt;
#include &lt;iostream&gt;

int main() {
    std::set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="5-std-map" data-toc="5-std-map"   >5. std::map</h3><ul class="list _ul" id="951a1fd1_2572"><li class="list__item" id="951a1fd1_2573"><p id="951a1fd1_2574">Sorted associative container (map).</p></li><li class="list__item" id="951a1fd1_2575"><p id="951a1fd1_2576">Stores key-value pairs in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;map&gt;
#include &lt;iostream&gt;

int main() {
    std::map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="6-std-unordered-set" data-toc="6-std-unordered-set"   >6. std::unordered_set</h3><ul class="list _ul" id="951a1fd1_2578"><li class="list__item" id="951a1fd1_2579"><p id="951a1fd1_2580">Unordered associative container (unordered set).</p></li><li class="list__item" id="951a1fd1_2581"><p id="951a1fd1_2582">Stores unique elements in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_set&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="7-std-unordered-map" data-toc="7-std-unordered-map"   >7. std::unordered_map</h3><ul class="list _ul" id="951a1fd1_2584"><li class="list__item" id="951a1fd1_2585"><p id="951a1fd1_2586">Unordered associative container (unordered map).</p></li><li class="list__item" id="951a1fd1_2587"><p id="951a1fd1_2588">Stores key-value pairs in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul><p id="951a1fd1_2590">These are just a few examples, and C++ provides other containers and variations to suit different needs. The choice of a container depends on the specific requirements of your program, such as the type of operations you need to perform and the performance characteristics you're aiming for.</p></section></section><section class="chapter"><h2 id="7-iterators" data-toc="7-iterators"   >7. Iterators</h2><p id="951a1fd1_2591">In C++, iterators are used to iterate over the elements of a container (like arrays, vectors, lists, etc.) in a sequential manner. Iterators act as a bridge between the algorithms and the containers, providing a way to access elements without exposing the underlying details of the container's implementation. There are different types of iterators, each with varying capabilities.</p><p id="951a1fd1_2592">Here are the main types of iterators in C++:</p><section class="chapter"><h3 id="1-input-iterators" data-toc="1-input-iterators"   >1. Input Iterators:</h3><ul class="list _ul" id="951a1fd1_2593"><li class="list__item" id="951a1fd1_2594"><p>Allow sequential access to the elements of a container in a forward direction.</p></li><li class="list__item" id="951a1fd1_2595"><p>Read-only access.</p></li><li class="list__item" id="951a1fd1_2596"><p>Single-pass, meaning you can traverse the container only once.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using input iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="2-output-iterators" data-toc="2-output-iterators"   >2. Output Iterators:</h3><ul class="list _ul" id="951a1fd1_2598"><li class="list__item" id="951a1fd1_2599"><p>Allow sequential access to the elements of a container for writing.</p></li><li class="list__item" id="951a1fd1_2600"><p>Write-only access.</p></li><li class="list__item" id="951a1fd1_2601"><p>Single-pass.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers;

    // Example of using output iterators
    for (int i = 1; i &lt;= 5; ++i) {
        numbers.push_back(i);
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="3-forward-iterators" data-toc="3-forward-iterators"   >3. Forward Iterators:</h3><ul class="list _ul" id="951a1fd1_2603"><li class="list__item" id="951a1fd1_2604"><p>Allow both reading and writing of elements.</p></li><li class="list__item" id="951a1fd1_2605"><p>Support multiple passes over the container.</p></li><li class="list__item" id="951a1fd1_2606"><p>Can be used with algorithms that require bidirectional or random access iterators.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;forward_list&gt;

int main() {
    std::forward_list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using forward iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Modify the elements using the iterator
        *it *= 2;
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="4-bidirectional-iterators" data-toc="4-bidirectional-iterators"   >4. Bidirectional Iterators:</h3><ul class="list _ul" id="951a1fd1_2608"><li class="list__item" id="951a1fd1_2609"><p>Support both forward and backward movement.</p></li><li class="list__item" id="951a1fd1_2610"><p>Used in algorithms that require backward traversal.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using bidirectional iterators
    auto it = numbers.end();
    while (it != numbers.begin()) {
        --it;
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="5-random-access-iterators" data-toc="5-random-access-iterators"   >5. Random Access Iterators:</h3><ul class="list _ul" id="951a1fd1_2612"><li class="list__item" id="951a1fd1_2613"><p>Support random access to elements (direct access by index).</p></li><li class="list__item" id="951a1fd1_2614"><p>Provide efficient movement in both forward and backward directions.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using random access iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Access elements using iterator as if it were a pointer
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    // Accessing elements directly by index
    std::cout &lt;&lt; &quot;\nThird element: &quot; &lt;&lt; numbers[2];

    return 0;
}
</div><p id="951a1fd1_2616">Understanding and using iterators is fundamental for working effectively with the C++ Standard Template Library and its algorithms.</p></section></section><section class="chapter"><h2 id="8-allocators" data-toc="8-allocators"   >8. Allocators</h2><p id="951a1fd1_2617">In C++, allocators are objects responsible for allocating and deallocating memory for containers. They provide a level of abstraction between the container and the memory management system. The <code class="code" id="951a1fd1_2618">std::allocator</code> is the default allocator provided by the C++ Standard Library, but custom allocators can be implemented to tailor memory management to specific needs.</p><p id="951a1fd1_2619">Here's a brief explanation of allocators along with an example using <code class="code" id="951a1fd1_2620">std::allocator</code>:</p><section class="chapter"><h3 id="std-allocator-example" data-toc="std-allocator-example"   >std::allocator Example:</h3><p id="951a1fd1_2621">The <code class="code" id="951a1fd1_2622">std::allocator</code> template class is a simple allocator that uses <code class="code" id="951a1fd1_2623">new</code> and <code class="code" id="951a1fd1_2624">delete</code> to allocate and deallocate memory. It is the default allocator for most C++ Standard Library containers.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt; // for std::allocator

int main() {
    // Example using std::allocator with std::vector
    std::allocator&lt;int&gt; myAllocator;

    // Allocate memory for an array of 5 integers
    int* data = myAllocator.allocate(5);

    // Initialize the allocated memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.construct(&amp;data[i], i + 1);
    }

    // Use the initialized data
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    // Deallocate the memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.destroy(&amp;data[i]);
    }
    myAllocator.deallocate(data, 5);

    return 0;
}
</div><p id="951a1fd1_2626">In this example:</p><ul class="list _ul" id="951a1fd1_2627"><li class="list__item" id="951a1fd1_2628"><p><code class="code" id="951a1fd1_2629">myAllocator.allocate(5)</code> allocates memory for an array of 5 integers.</p></li><li class="list__item" id="951a1fd1_2630"><p><code class="code" id="951a1fd1_2631">myAllocator.construct(&amp;data[i], i + 1)</code> initializes each element in the allocated memory.</p></li><li class="list__item" id="951a1fd1_2632"><p><code class="code" id="951a1fd1_2633">myAllocator.destroy(&amp;data[i])</code> is used to explicitly call the destructor for each element.</p></li><li class="list__item" id="951a1fd1_2634"><p><code class="code" id="951a1fd1_2635">myAllocator.deallocate(data, 5)</code> deallocates the memory.</p></li></ul></section><section class="chapter"><h3 id="custom-allocators" data-toc="custom-allocators"   >Custom Allocators:</h3><p id="951a1fd1_2636">You can create custom allocators by implementing a class that adheres to the allocator interface. The allocator interface typically includes functions like <code class="code" id="951a1fd1_2637">allocate</code>, <code class="code" id="951a1fd1_2638">deallocate</code>, <code class="code" id="951a1fd1_2639">construct</code>, and <code class="code" id="951a1fd1_2640">destroy</code>.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
struct MyAllocator {
    using value_type = T;

    MyAllocator() = default;

    T* allocate(std::size_t n) {
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, std::size_t n) {
        ::operator delete(p);
    }

    template &lt;typename... Args&gt;
    void construct(T* p, Args&amp;&amp;... args) {
        new (p) T(std::forward&lt;Args&gt;(args)...);
    }

    void destroy(T* p) {
        p-&gt;~T();
    }
};

int main() {
    // Example using a custom allocator with std::vector
    std::vector&lt;int, MyAllocator&lt;int&gt;&gt; myVector({1, 2, 3, 4, 5});

    for (const auto&amp; value : myVector) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div><p id="951a1fd1_2642">In this example, <code class="code" id="951a1fd1_2643">MyAllocator</code> is a simple custom allocator that uses <code class="code" id="951a1fd1_2644">operator new</code> and <code class="code" id="951a1fd1_2645">operator delete</code> for memory management. The <code class="code" id="951a1fd1_2646">std::vector</code> is then instantiated with this custom allocator.</p></section></section><div class="last-modified"> Last modified: 23 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="templates-and-template-metaprogramming.html">Templates and Template Metaprogramming</a>   <a class="navigation-links__next" href="string-type.html">String type</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>