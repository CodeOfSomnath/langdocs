<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-23T13:33:12.039137"><meta name="build-number" content="${buildNumber}">       <title>STL Algorithms and Data Structures | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-non-modifying-sequence-operations","level":0,"title":"2. Non-modifying Sequence Operations","anchor":"#2-non-modifying-sequence-operations"},{"id":"3-modifying-sequence-operations","level":0,"title":"3. Modifying Sequence Operations","anchor":"#3-modifying-sequence-operations"},{"id":"4-sorting-and-searching-operations","level":0,"title":"4. Sorting and Searching Operations","anchor":"#4-sorting-and-searching-operations"},{"id":"5-numeric-operations","level":0,"title":"5. Numeric Operations","anchor":"#5-numeric-operations"},{"id":"6-containers","level":0,"title":"6. Containers","anchor":"#6-containers"},{"id":"7-iterators","level":0,"title":"7. Iterators","anchor":"#7-iterators"},{"id":"8-allocators","level":0,"title":"8. Allocators","anchor":"#8-allocators"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="STL Algorithms and Data Structures | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="stl-algorithms-and-data-structures.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="STL Algorithms and Data Structures | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "stl-algorithms-and-data-structures.html#webpage", "url": "stl-algorithms-and-data-structures.html", "name": "STL Algorithms and Data Structures | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="STL-Algorithms-and-Data-Structures" data-main-title="STL Algorithms and Data Structures" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Cpp-Language.md|Cpp Language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="STL-Algorithms-and-Data-Structures"   id="STL-Algorithms-and-Data-Structures.md">STL Algorithms and Data Structures</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><p id="610e658e_648">The C++ Standard Template Library (STL) provides a collection of generic algorithms and data structures that are widely used in C++ programming. These components are implemented as templates, allowing them to work with different data types. Here's an overview of some key categories of STL algorithms and data structures:</p><section class="chapter"><h3 id="stl-algorithms" data-toc="stl-algorithms"   >STL Algorithms:</h3><ol class="list _decimal" id="610e658e_649" type="1"><li class="list__item" id="610e658e_650"><p id="610e658e_651"><span class="control" id="610e658e_652">Non-modifying Sequence Operations:</span></p><ul class="list _ul" id="610e658e_653"><li class="list__item" id="610e658e_654"><p><span class="control" id="610e658e_655"><code class="code" id="610e658e_656">std::for_each</code></span>: Applies a function to each element in a range.</p></li><li class="list__item" id="610e658e_657"><p><span class="control" id="610e658e_658"><code class="code" id="610e658e_659">std::count</code></span>: Counts the occurrences of a value in a range.</p></li><li class="list__item" id="610e658e_660"><p><span class="control" id="610e658e_661"><code class="code" id="610e658e_662">std::find</code></span>: Finds the first occurrence of a value in a range.</p></li><li class="list__item" id="610e658e_663"><p><span class="control" id="610e658e_664"><code class="code" id="610e658e_665">std::all_of</code>, <code class="code" id="610e658e_666">std::any_of</code>, <code class="code" id="610e658e_667">std::none_of</code></span>: Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul></li><li class="list__item" id="610e658e_668"><p id="610e658e_669"><span class="control" id="610e658e_670">Modifying Sequence Operations:</span></p><ul class="list _ul" id="610e658e_671"><li class="list__item" id="610e658e_672"><p><span class="control" id="610e658e_673"><code class="code" id="610e658e_674">std::copy</code></span>: Copies elements from one range to another.</p></li><li class="list__item" id="610e658e_675"><p><span class="control" id="610e658e_676"><code class="code" id="610e658e_677">std::transform</code></span>: Applies a function to each element in a range and stores the result in another range.</p></li><li class="list__item" id="610e658e_678"><p><span class="control" id="610e658e_679"><code class="code" id="610e658e_680">std::remove</code>, <code class="code" id="610e658e_681">std::remove_if</code></span>: Removes elements from a range based on a condition.</p></li><li class="list__item" id="610e658e_682"><p><span class="control" id="610e658e_683"><code class="code" id="610e658e_684">std::replace</code>, <code class="code" id="610e658e_685">std::replace_if</code></span>: Replaces elements in a range with a specified value or based on a condition.</p></li></ul></li><li class="list__item" id="610e658e_686"><p id="610e658e_687"><span class="control" id="610e658e_688">Sorting and Searching Operations:</span></p><ul class="list _ul" id="610e658e_689"><li class="list__item" id="610e658e_690"><p><span class="control" id="610e658e_691"><code class="code" id="610e658e_692">std::sort</code></span>: Sorts elements in a range.</p></li><li class="list__item" id="610e658e_693"><p><span class="control" id="610e658e_694"><code class="code" id="610e658e_695">std::binary_search</code></span>: Performs binary search on a sorted range.</p></li><li class="list__item" id="610e658e_696"><p><span class="control" id="610e658e_697"><code class="code" id="610e658e_698">std::merge</code></span>: Merges two sorted ranges into a single sorted range.</p></li><li class="list__item" id="610e658e_699"><p><span class="control" id="610e658e_700"><code class="code" id="610e658e_701">std::lower_bound</code>, <code class="code" id="610e658e_702">std::upper_bound</code></span>: Find the lower/upper bound of a value in a sorted range.</p></li></ul></li><li class="list__item" id="610e658e_703"><p id="610e658e_704"><span class="control" id="610e658e_705">Numeric Operations:</span></p><ul class="list _ul" id="610e658e_706"><li class="list__item" id="610e658e_707"><p><span class="control" id="610e658e_708"><code class="code" id="610e658e_709">std::accumulate</code></span>: Computes the sum of elements in a range.</p></li><li class="list__item" id="610e658e_710"><p><span class="control" id="610e658e_711"><code class="code" id="610e658e_712">std::inner_product</code></span>: Computes the inner product of two ranges.</p></li><li class="list__item" id="610e658e_713"><p><span class="control" id="610e658e_714"><code class="code" id="610e658e_715">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p></li></ul></li></ol></section><section class="chapter"><h3 id="stl-data-structures" data-toc="stl-data-structures"   >STL Data Structures:</h3><ol class="list _decimal" id="610e658e_716" type="1"><li class="list__item" id="610e658e_717"><p id="610e658e_718"><span class="control" id="610e658e_719">Containers:</span></p><ul class="list _ul" id="610e658e_720"><li class="list__item" id="610e658e_721"><p><span class="control" id="610e658e_722"><code class="code" id="610e658e_723">std::vector</code></span>: Dynamic array.</p></li><li class="list__item" id="610e658e_724"><p><span class="control" id="610e658e_725"><code class="code" id="610e658e_726">std::list</code></span>: Doubly-linked list.</p></li><li class="list__item" id="610e658e_727"><p><span class="control" id="610e658e_728"><code class="code" id="610e658e_729">std::deque</code></span>: Double-ended queue.</p></li><li class="list__item" id="610e658e_730"><p><span class="control" id="610e658e_731"><code class="code" id="610e658e_732">std::queue</code></span>: FIFO queue (adapter).</p></li><li class="list__item" id="610e658e_733"><p><span class="control" id="610e658e_734"><code class="code" id="610e658e_735">std::stack</code></span>: LIFO stack (adapter).</p></li><li class="list__item" id="610e658e_736"><p><span class="control" id="610e658e_737"><code class="code" id="610e658e_738">std::set</code></span>, <span class="control" id="610e658e_739"><code class="code" id="610e658e_740">std::multiset</code></span>: Sorted associative containers (sets).</p></li><li class="list__item" id="610e658e_741"><p><span class="control" id="610e658e_742"><code class="code" id="610e658e_743">std::map</code></span>, <span class="control" id="610e658e_744"><code class="code" id="610e658e_745">std::multimap</code></span>: Sorted associative containers (maps).</p></li><li class="list__item" id="610e658e_746"><p><span class="control" id="610e658e_747"><code class="code" id="610e658e_748">std::unordered_set</code></span>, <span class="control" id="610e658e_749"><code class="code" id="610e658e_750">std::unordered_multiset</code></span>: Unordered associative containers (unordered sets).</p></li><li class="list__item" id="610e658e_751"><p><span class="control" id="610e658e_752"><code class="code" id="610e658e_753">std::unordered_map</code></span>, <span class="control" id="610e658e_754"><code class="code" id="610e658e_755">std::unordered_multimap</code></span>: Unordered associative containers (unordered maps).</p></li></ul></li><li class="list__item" id="610e658e_756"><p id="610e658e_757"><span class="control" id="610e658e_758">Iterators:</span></p><ul class="list _ul" id="610e658e_759"><li class="list__item" id="610e658e_760"><p><span class="control" id="610e658e_761">Input Iterators</span>: Read-only access, single-pass.</p></li><li class="list__item" id="610e658e_762"><p><span class="control" id="610e658e_763">Output Iterators</span>: Write-only access, single-pass.</p></li><li class="list__item" id="610e658e_764"><p><span class="control" id="610e658e_765">Forward Iterators</span>: Read/write access, multiple-pass.</p></li><li class="list__item" id="610e658e_766"><p><span class="control" id="610e658e_767">Bidirectional Iterators</span>: Read/write access, bidirectional movement.</p></li><li class="list__item" id="610e658e_768"><p><span class="control" id="610e658e_769">Random Access Iterators</span>: Read/write access, random movement.</p></li></ul></li><li class="list__item" id="610e658e_770"><p id="610e658e_771"><span class="control" id="610e658e_772">Allocators:</span></p><ul class="list _ul" id="610e658e_773"><li class="list__item" id="610e658e_774"><p><span class="control" id="610e658e_775"><code class="code" id="610e658e_776">std::allocator</code></span>: Default allocator.</p></li><li class="list__item" id="610e658e_777"><p>Custom allocators can be used for memory management in containers.</p></li></ul></li></ol><p id="610e658e_778">These are just some examples, and there are many more algorithms and data structures in the STL. Understanding these components is crucial for efficient and expressive C++ programming.</p></section></section><section class="chapter"><h2 id="2-non-modifying-sequence-operations" data-toc="2-non-modifying-sequence-operations"   >2. Non-modifying Sequence Operations</h2><p id="610e658e_779">Non-modifying sequence operations in the C++ Standard Template Library (STL) are algorithms that operate on sequences ( ranges) without modifying the elements in the sequence. Here are some common non-modifying sequence operations along with examples:</p><ol class="list _decimal" id="610e658e_780" type="1"><li class="list__item" id="610e658e_781"><p id="610e658e_782"><span class="control" id="610e658e_783"><code class="code" id="610e658e_784">std::for_each</code>:</span></p><ul class="list _ul" id="610e658e_785"><li class="list__item" id="610e658e_786"><p>Applies a given function to each element in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void printSquare(int x) {
    std::cout &lt;&lt; x * x &lt;&lt; &quot; &quot;;
}

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::for_each(numbers.begin(), numbers.end(), printSquare);

    // Output: 1 4 9 16 25
    return 0;
}
</div></li><li class="list__item" id="610e658e_788"><p id="610e658e_789"><span class="control" id="610e658e_790"><code class="code" id="610e658e_791">std::count</code>:</span></p><ul class="list _ul" id="610e658e_792"><li class="list__item" id="610e658e_793"><p>Counts the occurrences of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 2, 4, 2, 5};

    int countOfTwos = std::count(numbers.begin(), numbers.end(), 2);

    // Output: Count of 2: 3
    std::cout &lt;&lt; &quot;Count of 2: &quot; &lt;&lt; countOfTwos &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="610e658e_795"><p id="610e658e_796"><span class="control" id="610e658e_797"><code class="code" id="610e658e_798">std::find</code>:</span></p><ul class="list _ul" id="610e658e_799"><li class="list__item" id="610e658e_800"><p>Finds the first occurrence of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    auto it = std::find(numbers.begin(), numbers.end(), 3);

    if (it != numbers.end()) {
        // Output: 3 found at position 2
        std::cout &lt;&lt; *it &lt;&lt; &quot; found at position &quot; &lt;&lt; std::distance(numbers.begin(), it) &lt;&lt; std::endl;
    } else {
        // Output: 3 not found
        std::cout &lt;&lt; &quot;3 not found&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</div></li><li class="list__item" id="610e658e_802"><p id="610e658e_803"><span class="control" id="610e658e_804"><code class="code" id="610e658e_805">std::all_of</code>, <code class="code" id="610e658e_806">std::any_of</code>, <code class="code" id="610e658e_807">std::none_of</code>:</span></p><ul class="list _ul" id="610e658e_808"><li class="list__item" id="610e658e_809"><p>Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {2, 4, 6, 8, 10};

    // Output: All are even: 1
    std::cout &lt;&lt; &quot;All are even: &quot; &lt;&lt; std::all_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 == 0; }) &lt;&lt; std::endl;

    // Output: Any is odd: 0
    std::cout &lt;&lt; &quot;Any is odd: &quot; &lt;&lt; std::any_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    // Output: None is odd: 1
    std::cout &lt;&lt; &quot;None is odd: &quot; &lt;&lt; std::none_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="610e658e_811">These examples illustrate the usage of non-modifying sequence operations in the STL, providing various ways to interact with and analyze sequences without altering their content.</p></section><section class="chapter"><h2 id="3-modifying-sequence-operations" data-toc="3-modifying-sequence-operations"   >3. Modifying Sequence Operations</h2><p id="610e658e_812">Modifying Sequence Operations in C++ STL are a set of algorithms that perform modifications directly on the elements of a sequence (like arrays or containers) in a generic way. These algorithms can be used to manipulate the contents of a range or container. Here are some common modifying sequence operations along with examples:</p><section class="chapter"><h3 id="std-copy" data-toc="std-copy"   >std::copy:</h3><p id="610e658e_813">The <code class="code" id="610e658e_814">std::copy</code> algorithm is used to copy elements from one range to another.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; source = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; destination(source.size());

    // Copy elements from source to destination
    std::copy(source.begin(), source.end(), destination.begin());

    // Print the contents of the destination vector
    for (int num : destination) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-transform" data-toc="std-transform"   >std::transform:</h3><p id="610e658e_816">The <code class="code" id="610e658e_817">std::transform</code> algorithm applies a specified operation to each element in a range and stores the result in another range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; squared_numbers(numbers.size());

    // Square each element and store the result in squared_numbers
    std::transform(numbers.begin(), numbers.end(), squared_numbers.begin(),
                   [](int x) { return x * x; });

    // Print the squared numbers
    for (int num : squared_numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-remove-and-std-remove-if" data-toc="std-remove-and-std-remove-if"   >std::remove and std::remove_if:</h3><p id="610e658e_819">These algorithms are used to remove elements from a range based on a specified value or condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Remove all occurrences of the value 2
    auto new_end = std::remove(numbers.begin(), numbers.end(), 2);

    // Resize the container to the new size after removal
    numbers.resize(std::distance(numbers.begin(), new_end));

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-replace-and-std-replace-if" data-toc="std-replace-and-std-replace-if"   >std::replace and std::replace_if:</h3><p id="610e658e_821">These algorithms replace elements in a range with a specified value or based on a condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Replace all occurrences of the value 2 with 0
    std::replace(numbers.begin(), numbers.end(), 2, 0);

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div><p id="610e658e_823">These examples illustrate the use of modifying sequence operations in the C++ STL to manipulate the contents of sequences or containers.</p></section></section><section class="chapter"><h2 id="4-sorting-and-searching-operations" data-toc="4-sorting-and-searching-operations"   >4. Sorting and Searching Operations</h2><p id="610e658e_824">Sure, let's delve into Sorting and Searching Operations in C++ using the STL.</p><section class="chapter"><h3 id="sorting-operations" data-toc="sorting-operations"   >Sorting Operations:</h3><section class="chapter"><h4 id="std-sort" data-toc="std-sort"   >std::sort:</h4><p id="610e658e_825">This algorithm is used to sort elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 7};

    std::sort(numbers.begin(), numbers.end());

    // Output: 1 2 5 7 8
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-stable-sort" data-toc="std-stable-sort"   >std::stable_sort:</h4><p id="610e658e_827">Similar to <code class="code" id="610e658e_828">std::sort</code>, but maintains the relative order of equal elements.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;std::pair&lt;int, std::string&gt;&gt; data = {{5, &quot;five&quot;}, {2, &quot;two&quot;}, {8, &quot;eight&quot;}, {1, &quot;one&quot;}, {7, &quot;seven&quot;}};

    std::stable_sort(data.begin(), data.end(), [](const auto&amp; a, const auto&amp; b) {
        return a.first &lt; b.first;
    });

    // Output: (1, &quot;one&quot;) (2, &quot;two&quot;) (5, &quot;five&quot;) (7, &quot;seven&quot;) (8, &quot;eight&quot;)
    for (const auto&amp; pair : data) {
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\&quot;) &quot;;
    }

    return 0;
}
</div></section></section><section class="chapter"><h3 id="searching-operations" data-toc="searching-operations"   >Searching Operations:</h3><section class="chapter"><h4 id="std-binary-search" data-toc="std-binary-search"   >std::binary_search:</h4><p id="610e658e_830">Performs binary search on a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    bool found = std::binary_search(numbers.begin(), numbers.end(), 5);

    // Output: Found
    if (found) {
        std::cout &lt;&lt; &quot;Found\n&quot;;
    } else {
        std::cout &lt;&lt; &quot;Not Found\n&quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-lower-bound-and-std-upper-bound" data-toc="std-lower-bound-and-std-upper-bound"   >std::lower_bound and std::upper_bound:</h4><p id="610e658e_832">Find the lower/upper bound of a value in a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    auto lower = std::lower_bound(numbers.begin(), numbers.end(), 5);
    auto upper = std::upper_bound(numbers.begin(), numbers.end(), 5);

    // Output: Lower Bound: 5, Upper Bound: 7
    std::cout &lt;&lt; &quot;Lower Bound: &quot; &lt;&lt; *lower &lt;&lt; &quot;, Upper Bound: &quot; &lt;&lt; *upper &lt;&lt; std::endl;

    return 0;
}
</div><p id="610e658e_834">These examples demonstrate some common sorting and searching operations using the STL in C++. Feel free to experiment with different data types and adapt these examples to your specific use cases.</p></section></section></section><section class="chapter"><h2 id="5-numeric-operations" data-toc="5-numeric-operations"   >5. Numeric Operations</h2><p id="610e658e_835">Numeric operations in C++ involve various algorithms for performing computations on numerical data. The <code class="code" id="610e658e_836">&lt;numeric&gt;</code> header in the Standard Template Library (STL) provides several functions that are commonly used for such operations. Here are some key numeric operations along with examples:</p><ol class="list _decimal" id="610e658e_837" type="1"><li class="list__item" id="610e658e_838"><p id="610e658e_839"><span class="control" id="610e658e_840"><code class="code" id="610e658e_841">std::accumulate</code></span>: Computes the sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="610e658e_843"><p id="610e658e_844"><span class="control" id="610e658e_845"><code class="code" id="610e658e_846">std::inner_product</code></span>: Computes the inner product of two ranges.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; a = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; b = {2, 2, 2, 2, 2};

    int result = std::inner_product(a.begin(), a.end(), b.begin(), 0);

    std::cout &lt;&lt; &quot;Inner Product: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="610e658e_848"><p id="610e658e_849"><span class="control" id="610e658e_850"><code class="code" id="610e658e_851">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::vector&lt;int&gt; partial_sums(numbers.size());
    std::partial_sum(numbers.begin(), numbers.end(), partial_sums.begin());

    std::cout &lt;&lt; &quot;Partial Sums: &quot;;
    for (int value : partial_sums) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="610e658e_853">These examples demonstrate how to use <code class="code" id="610e658e_854">std::accumulate</code>, <code class="code" id="610e658e_855">std::inner_product</code>, and <code class="code" id="610e658e_856">std::partial_sum</code> to perform common numeric operations. The <code class="code" id="610e658e_857">&lt;numeric&gt;</code> header provides other functions as well, so it's worth exploring the documentation for additional functionality related to numeric computations in C++.</p></section><section class="chapter"><h2 id="6-containers" data-toc="6-containers"   >6. Containers</h2><p id="610e658e_858">In C++, containers are objects that hold other objects. They are a crucial part of the Standard Template Library (STL) and provide various ways to store and organize data efficiently. Here are some commonly used containers in C++ along with examples:</p><section class="chapter"><h3 id="1-std-vector" data-toc="1-std-vector"   >1. std::vector</h3><ul class="list _ul" id="610e658e_859"><li class="list__item" id="610e658e_860"><p id="610e658e_861">Dynamic array that can resize itself.</p></li><li class="list__item" id="610e658e_862"><p id="610e658e_863">Elements are stored in contiguous memory.</p><div class="code-block" data-lang="cpp"         >
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="2-std-list" data-toc="2-std-list"   >2. std::list</h3><ul class="list _ul" id="610e658e_865"><li class="list__item" id="610e658e_866"><p id="610e658e_867">Doubly-linked list.</p></li><li class="list__item" id="610e658e_868"><p id="610e658e_869">Allows constant time insertions and deletions.</p><div class="code-block" data-lang="cpp"         >
#include &lt;list&gt;
#include &lt;iostream&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="3-std-deque" data-toc="3-std-deque"   >3. std::deque</h3><ul class="list _ul" id="610e658e_871"><li class="list__item" id="610e658e_872"><p id="610e658e_873">Double-ended queue.</p></li><li class="list__item" id="610e658e_874"><p id="610e658e_875">Similar to vectors but allows efficient insertion/removal at both ends.</p><div class="code-block" data-lang="cpp"         >
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    std::deque&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="4-std-set" data-toc="4-std-set"   >4. std::set</h3><ul class="list _ul" id="610e658e_877"><li class="list__item" id="610e658e_878"><p id="610e658e_879">Sorted associative container (set).</p></li><li class="list__item" id="610e658e_880"><p id="610e658e_881">Stores unique elements in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;set&gt;
#include &lt;iostream&gt;

int main() {
    std::set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="5-std-map" data-toc="5-std-map"   >5. std::map</h3><ul class="list _ul" id="610e658e_883"><li class="list__item" id="610e658e_884"><p id="610e658e_885">Sorted associative container (map).</p></li><li class="list__item" id="610e658e_886"><p id="610e658e_887">Stores key-value pairs in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;map&gt;
#include &lt;iostream&gt;

int main() {
    std::map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="6-std-unordered-set" data-toc="6-std-unordered-set"   >6. std::unordered_set</h3><ul class="list _ul" id="610e658e_889"><li class="list__item" id="610e658e_890"><p id="610e658e_891">Unordered associative container (unordered set).</p></li><li class="list__item" id="610e658e_892"><p id="610e658e_893">Stores unique elements in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_set&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="7-std-unordered-map" data-toc="7-std-unordered-map"   >7. std::unordered_map</h3><ul class="list _ul" id="610e658e_895"><li class="list__item" id="610e658e_896"><p id="610e658e_897">Unordered associative container (unordered map).</p></li><li class="list__item" id="610e658e_898"><p id="610e658e_899">Stores key-value pairs in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul><p id="610e658e_901">These are just a few examples, and C++ provides other containers and variations to suit different needs. The choice of a container depends on the specific requirements of your program, such as the type of operations you need to perform and the performance characteristics you're aiming for.</p></section></section><section class="chapter"><h2 id="7-iterators" data-toc="7-iterators"   >7. Iterators</h2><p id="610e658e_902">In C++, iterators are used to iterate over the elements of a container (like arrays, vectors, lists, etc.) in a sequential manner. Iterators act as a bridge between the algorithms and the containers, providing a way to access elements without exposing the underlying details of the container's implementation. There are different types of iterators, each with varying capabilities.</p><p id="610e658e_903">Here are the main types of iterators in C++:</p><section class="chapter"><h3 id="1-input-iterators" data-toc="1-input-iterators"   >1. Input Iterators:</h3><ul class="list _ul" id="610e658e_904"><li class="list__item" id="610e658e_905"><p>Allow sequential access to the elements of a container in a forward direction.</p></li><li class="list__item" id="610e658e_906"><p>Read-only access.</p></li><li class="list__item" id="610e658e_907"><p>Single-pass, meaning you can traverse the container only once.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using input iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="2-output-iterators" data-toc="2-output-iterators"   >2. Output Iterators:</h3><ul class="list _ul" id="610e658e_909"><li class="list__item" id="610e658e_910"><p>Allow sequential access to the elements of a container for writing.</p></li><li class="list__item" id="610e658e_911"><p>Write-only access.</p></li><li class="list__item" id="610e658e_912"><p>Single-pass.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers;

    // Example of using output iterators
    for (int i = 1; i &lt;= 5; ++i) {
        numbers.push_back(i);
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="3-forward-iterators" data-toc="3-forward-iterators"   >3. Forward Iterators:</h3><ul class="list _ul" id="610e658e_914"><li class="list__item" id="610e658e_915"><p>Allow both reading and writing of elements.</p></li><li class="list__item" id="610e658e_916"><p>Support multiple passes over the container.</p></li><li class="list__item" id="610e658e_917"><p>Can be used with algorithms that require bidirectional or random access iterators.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;forward_list&gt;

int main() {
    std::forward_list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using forward iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Modify the elements using the iterator
        *it *= 2;
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="4-bidirectional-iterators" data-toc="4-bidirectional-iterators"   >4. Bidirectional Iterators:</h3><ul class="list _ul" id="610e658e_919"><li class="list__item" id="610e658e_920"><p>Support both forward and backward movement.</p></li><li class="list__item" id="610e658e_921"><p>Used in algorithms that require backward traversal.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using bidirectional iterators
    auto it = numbers.end();
    while (it != numbers.begin()) {
        --it;
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="5-random-access-iterators" data-toc="5-random-access-iterators"   >5. Random Access Iterators:</h3><ul class="list _ul" id="610e658e_923"><li class="list__item" id="610e658e_924"><p>Support random access to elements (direct access by index).</p></li><li class="list__item" id="610e658e_925"><p>Provide efficient movement in both forward and backward directions.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using random access iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Access elements using iterator as if it were a pointer
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    // Accessing elements directly by index
    std::cout &lt;&lt; &quot;\nThird element: &quot; &lt;&lt; numbers[2];

    return 0;
}
</div><p id="610e658e_927">Understanding and using iterators is fundamental for working effectively with the C++ Standard Template Library and its algorithms.</p></section></section><section class="chapter"><h2 id="8-allocators" data-toc="8-allocators"   >8. Allocators</h2><p id="610e658e_928">In C++, allocators are objects responsible for allocating and deallocating memory for containers. They provide a level of abstraction between the container and the memory management system. The <code class="code" id="610e658e_929">std::allocator</code> is the default allocator provided by the C++ Standard Library, but custom allocators can be implemented to tailor memory management to specific needs.</p><p id="610e658e_930">Here's a brief explanation of allocators along with an example using <code class="code" id="610e658e_931">std::allocator</code>:</p><section class="chapter"><h3 id="std-allocator-example" data-toc="std-allocator-example"   >std::allocator Example:</h3><p id="610e658e_932">The <code class="code" id="610e658e_933">std::allocator</code> template class is a simple allocator that uses <code class="code" id="610e658e_934">new</code> and <code class="code" id="610e658e_935">delete</code> to allocate and deallocate memory. It is the default allocator for most C++ Standard Library containers.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt; // for std::allocator

int main() {
    // Example using std::allocator with std::vector
    std::allocator&lt;int&gt; myAllocator;

    // Allocate memory for an array of 5 integers
    int* data = myAllocator.allocate(5);

    // Initialize the allocated memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.construct(&amp;data[i], i + 1);
    }

    // Use the initialized data
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    // Deallocate the memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.destroy(&amp;data[i]);
    }
    myAllocator.deallocate(data, 5);

    return 0;
}
</div><p id="610e658e_937">In this example:</p><ul class="list _ul" id="610e658e_938"><li class="list__item" id="610e658e_939"><p><code class="code" id="610e658e_940">myAllocator.allocate(5)</code> allocates memory for an array of 5 integers.</p></li><li class="list__item" id="610e658e_941"><p><code class="code" id="610e658e_942">myAllocator.construct(&amp;data[i], i + 1)</code> initializes each element in the allocated memory.</p></li><li class="list__item" id="610e658e_943"><p><code class="code" id="610e658e_944">myAllocator.destroy(&amp;data[i])</code> is used to explicitly call the destructor for each element.</p></li><li class="list__item" id="610e658e_945"><p><code class="code" id="610e658e_946">myAllocator.deallocate(data, 5)</code> deallocates the memory.</p></li></ul></section><section class="chapter"><h3 id="custom-allocators" data-toc="custom-allocators"   >Custom Allocators:</h3><p id="610e658e_947">You can create custom allocators by implementing a class that adheres to the allocator interface. The allocator interface typically includes functions like <code class="code" id="610e658e_948">allocate</code>, <code class="code" id="610e658e_949">deallocate</code>, <code class="code" id="610e658e_950">construct</code>, and <code class="code" id="610e658e_951">destroy</code>.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
struct MyAllocator {
    using value_type = T;

    MyAllocator() = default;

    T* allocate(std::size_t n) {
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, std::size_t n) {
        ::operator delete(p);
    }

    template &lt;typename... Args&gt;
    void construct(T* p, Args&amp;&amp;... args) {
        new (p) T(std::forward&lt;Args&gt;(args)...);
    }

    void destroy(T* p) {
        p-&gt;~T();
    }
};

int main() {
    // Example using a custom allocator with std::vector
    std::vector&lt;int, MyAllocator&lt;int&gt;&gt; myVector({1, 2, 3, 4, 5});

    for (const auto&amp; value : myVector) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div><p id="610e658e_953">In this example, <code class="code" id="610e658e_954">MyAllocator</code> is a simple custom allocator that uses <code class="code" id="610e658e_955">operator new</code> and <code class="code" id="610e658e_956">operator delete</code> for memory management. The <code class="code" id="610e658e_957">std::vector</code> is then instantiated with this custom allocator.</p></section></section><div class="last-modified"> Last modified: 23 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="templates-and-template-metaprogramming.html">Templates and Template Metaprogramming</a>   <a class="navigation-links__next" href="string-type.html">String type</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>