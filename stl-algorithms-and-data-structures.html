<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-23T13:36:44.5988168"><meta name="build-number" content="${buildNumber}">       <title>STL Algorithms and Data Structures | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-non-modifying-sequence-operations","level":0,"title":"2. Non-modifying Sequence Operations","anchor":"#2-non-modifying-sequence-operations"},{"id":"3-modifying-sequence-operations","level":0,"title":"3. Modifying Sequence Operations","anchor":"#3-modifying-sequence-operations"},{"id":"4-sorting-and-searching-operations","level":0,"title":"4. Sorting and Searching Operations","anchor":"#4-sorting-and-searching-operations"},{"id":"5-numeric-operations","level":0,"title":"5. Numeric Operations","anchor":"#5-numeric-operations"},{"id":"6-containers","level":0,"title":"6. Containers","anchor":"#6-containers"},{"id":"7-iterators","level":0,"title":"7. Iterators","anchor":"#7-iterators"},{"id":"8-allocators","level":0,"title":"8. Allocators","anchor":"#8-allocators"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="STL Algorithms and Data Structures | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="stl-algorithms-and-data-structures.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="STL Algorithms and Data Structures | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "stl-algorithms-and-data-structures.html#webpage", "url": "stl-algorithms-and-data-structures.html", "name": "STL Algorithms and Data Structures | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="STL-Algorithms-and-Data-Structures" data-main-title="STL Algorithms and Data Structures" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Cpp-Language.md|Cpp Language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="STL-Algorithms-and-Data-Structures"   id="STL-Algorithms-and-Data-Structures.md">STL Algorithms and Data Structures</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><p id="610e658e_959">The C++ Standard Template Library (STL) provides a collection of generic algorithms and data structures that are widely used in C++ programming. These components are implemented as templates, allowing them to work with different data types. Here's an overview of some key categories of STL algorithms and data structures:</p><section class="chapter"><h3 id="stl-algorithms" data-toc="stl-algorithms"   >STL Algorithms:</h3><ol class="list _decimal" id="610e658e_960" type="1"><li class="list__item" id="610e658e_961"><p id="610e658e_962"><span class="control" id="610e658e_963">Non-modifying Sequence Operations:</span></p><ul class="list _ul" id="610e658e_964"><li class="list__item" id="610e658e_965"><p><span class="control" id="610e658e_966"><code class="code" id="610e658e_967">std::for_each</code></span>: Applies a function to each element in a range.</p></li><li class="list__item" id="610e658e_968"><p><span class="control" id="610e658e_969"><code class="code" id="610e658e_970">std::count</code></span>: Counts the occurrences of a value in a range.</p></li><li class="list__item" id="610e658e_971"><p><span class="control" id="610e658e_972"><code class="code" id="610e658e_973">std::find</code></span>: Finds the first occurrence of a value in a range.</p></li><li class="list__item" id="610e658e_974"><p><span class="control" id="610e658e_975"><code class="code" id="610e658e_976">std::all_of</code>, <code class="code" id="610e658e_977">std::any_of</code>, <code class="code" id="610e658e_978">std::none_of</code></span>: Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul></li><li class="list__item" id="610e658e_979"><p id="610e658e_980"><span class="control" id="610e658e_981">Modifying Sequence Operations:</span></p><ul class="list _ul" id="610e658e_982"><li class="list__item" id="610e658e_983"><p><span class="control" id="610e658e_984"><code class="code" id="610e658e_985">std::copy</code></span>: Copies elements from one range to another.</p></li><li class="list__item" id="610e658e_986"><p><span class="control" id="610e658e_987"><code class="code" id="610e658e_988">std::transform</code></span>: Applies a function to each element in a range and stores the result in another range.</p></li><li class="list__item" id="610e658e_989"><p><span class="control" id="610e658e_990"><code class="code" id="610e658e_991">std::remove</code>, <code class="code" id="610e658e_992">std::remove_if</code></span>: Removes elements from a range based on a condition.</p></li><li class="list__item" id="610e658e_993"><p><span class="control" id="610e658e_994"><code class="code" id="610e658e_995">std::replace</code>, <code class="code" id="610e658e_996">std::replace_if</code></span>: Replaces elements in a range with a specified value or based on a condition.</p></li></ul></li><li class="list__item" id="610e658e_997"><p id="610e658e_998"><span class="control" id="610e658e_999">Sorting and Searching Operations:</span></p><ul class="list _ul" id="610e658e_1000"><li class="list__item" id="610e658e_1001"><p><span class="control" id="610e658e_1002"><code class="code" id="610e658e_1003">std::sort</code></span>: Sorts elements in a range.</p></li><li class="list__item" id="610e658e_1004"><p><span class="control" id="610e658e_1005"><code class="code" id="610e658e_1006">std::binary_search</code></span>: Performs binary search on a sorted range.</p></li><li class="list__item" id="610e658e_1007"><p><span class="control" id="610e658e_1008"><code class="code" id="610e658e_1009">std::merge</code></span>: Merges two sorted ranges into a single sorted range.</p></li><li class="list__item" id="610e658e_1010"><p><span class="control" id="610e658e_1011"><code class="code" id="610e658e_1012">std::lower_bound</code>, <code class="code" id="610e658e_1013">std::upper_bound</code></span>: Find the lower/upper bound of a value in a sorted range.</p></li></ul></li><li class="list__item" id="610e658e_1014"><p id="610e658e_1015"><span class="control" id="610e658e_1016">Numeric Operations:</span></p><ul class="list _ul" id="610e658e_1017"><li class="list__item" id="610e658e_1018"><p><span class="control" id="610e658e_1019"><code class="code" id="610e658e_1020">std::accumulate</code></span>: Computes the sum of elements in a range.</p></li><li class="list__item" id="610e658e_1021"><p><span class="control" id="610e658e_1022"><code class="code" id="610e658e_1023">std::inner_product</code></span>: Computes the inner product of two ranges.</p></li><li class="list__item" id="610e658e_1024"><p><span class="control" id="610e658e_1025"><code class="code" id="610e658e_1026">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p></li></ul></li></ol></section><section class="chapter"><h3 id="stl-data-structures" data-toc="stl-data-structures"   >STL Data Structures:</h3><ol class="list _decimal" id="610e658e_1027" type="1"><li class="list__item" id="610e658e_1028"><p id="610e658e_1029"><span class="control" id="610e658e_1030">Containers:</span></p><ul class="list _ul" id="610e658e_1031"><li class="list__item" id="610e658e_1032"><p><span class="control" id="610e658e_1033"><code class="code" id="610e658e_1034">std::vector</code></span>: Dynamic array.</p></li><li class="list__item" id="610e658e_1035"><p><span class="control" id="610e658e_1036"><code class="code" id="610e658e_1037">std::list</code></span>: Doubly-linked list.</p></li><li class="list__item" id="610e658e_1038"><p><span class="control" id="610e658e_1039"><code class="code" id="610e658e_1040">std::deque</code></span>: Double-ended queue.</p></li><li class="list__item" id="610e658e_1041"><p><span class="control" id="610e658e_1042"><code class="code" id="610e658e_1043">std::queue</code></span>: FIFO queue (adapter).</p></li><li class="list__item" id="610e658e_1044"><p><span class="control" id="610e658e_1045"><code class="code" id="610e658e_1046">std::stack</code></span>: LIFO stack (adapter).</p></li><li class="list__item" id="610e658e_1047"><p><span class="control" id="610e658e_1048"><code class="code" id="610e658e_1049">std::set</code></span>, <span class="control" id="610e658e_1050"><code class="code" id="610e658e_1051">std::multiset</code></span>: Sorted associative containers (sets).</p></li><li class="list__item" id="610e658e_1052"><p><span class="control" id="610e658e_1053"><code class="code" id="610e658e_1054">std::map</code></span>, <span class="control" id="610e658e_1055"><code class="code" id="610e658e_1056">std::multimap</code></span>: Sorted associative containers (maps).</p></li><li class="list__item" id="610e658e_1057"><p><span class="control" id="610e658e_1058"><code class="code" id="610e658e_1059">std::unordered_set</code></span>, <span class="control" id="610e658e_1060"><code class="code" id="610e658e_1061">std::unordered_multiset</code></span>: Unordered associative containers (unordered sets).</p></li><li class="list__item" id="610e658e_1062"><p><span class="control" id="610e658e_1063"><code class="code" id="610e658e_1064">std::unordered_map</code></span>, <span class="control" id="610e658e_1065"><code class="code" id="610e658e_1066">std::unordered_multimap</code></span>: Unordered associative containers (unordered maps).</p></li></ul></li><li class="list__item" id="610e658e_1067"><p id="610e658e_1068"><span class="control" id="610e658e_1069">Iterators:</span></p><ul class="list _ul" id="610e658e_1070"><li class="list__item" id="610e658e_1071"><p><span class="control" id="610e658e_1072">Input Iterators</span>: Read-only access, single-pass.</p></li><li class="list__item" id="610e658e_1073"><p><span class="control" id="610e658e_1074">Output Iterators</span>: Write-only access, single-pass.</p></li><li class="list__item" id="610e658e_1075"><p><span class="control" id="610e658e_1076">Forward Iterators</span>: Read/write access, multiple-pass.</p></li><li class="list__item" id="610e658e_1077"><p><span class="control" id="610e658e_1078">Bidirectional Iterators</span>: Read/write access, bidirectional movement.</p></li><li class="list__item" id="610e658e_1079"><p><span class="control" id="610e658e_1080">Random Access Iterators</span>: Read/write access, random movement.</p></li></ul></li><li class="list__item" id="610e658e_1081"><p id="610e658e_1082"><span class="control" id="610e658e_1083">Allocators:</span></p><ul class="list _ul" id="610e658e_1084"><li class="list__item" id="610e658e_1085"><p><span class="control" id="610e658e_1086"><code class="code" id="610e658e_1087">std::allocator</code></span>: Default allocator.</p></li><li class="list__item" id="610e658e_1088"><p>Custom allocators can be used for memory management in containers.</p></li></ul></li></ol><p id="610e658e_1089">These are just some examples, and there are many more algorithms and data structures in the STL. Understanding these components is crucial for efficient and expressive C++ programming.</p></section></section><section class="chapter"><h2 id="2-non-modifying-sequence-operations" data-toc="2-non-modifying-sequence-operations"   >2. Non-modifying Sequence Operations</h2><p id="610e658e_1090">Non-modifying sequence operations in the C++ Standard Template Library (STL) are algorithms that operate on sequences ( ranges) without modifying the elements in the sequence. Here are some common non-modifying sequence operations along with examples:</p><ol class="list _decimal" id="610e658e_1091" type="1"><li class="list__item" id="610e658e_1092"><p id="610e658e_1093"><span class="control" id="610e658e_1094"><code class="code" id="610e658e_1095">std::for_each</code>:</span></p><ul class="list _ul" id="610e658e_1096"><li class="list__item" id="610e658e_1097"><p>Applies a given function to each element in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void printSquare(int x) {
    std::cout &lt;&lt; x * x &lt;&lt; &quot; &quot;;
}

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::for_each(numbers.begin(), numbers.end(), printSquare);

    // Output: 1 4 9 16 25
    return 0;
}
</div></li><li class="list__item" id="610e658e_1099"><p id="610e658e_1100"><span class="control" id="610e658e_1101"><code class="code" id="610e658e_1102">std::count</code>:</span></p><ul class="list _ul" id="610e658e_1103"><li class="list__item" id="610e658e_1104"><p>Counts the occurrences of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 2, 4, 2, 5};

    int countOfTwos = std::count(numbers.begin(), numbers.end(), 2);

    // Output: Count of 2: 3
    std::cout &lt;&lt; &quot;Count of 2: &quot; &lt;&lt; countOfTwos &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="610e658e_1106"><p id="610e658e_1107"><span class="control" id="610e658e_1108"><code class="code" id="610e658e_1109">std::find</code>:</span></p><ul class="list _ul" id="610e658e_1110"><li class="list__item" id="610e658e_1111"><p>Finds the first occurrence of a specified value in a range.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    auto it = std::find(numbers.begin(), numbers.end(), 3);

    if (it != numbers.end()) {
        // Output: 3 found at position 2
        std::cout &lt;&lt; *it &lt;&lt; &quot; found at position &quot; &lt;&lt; std::distance(numbers.begin(), it) &lt;&lt; std::endl;
    } else {
        // Output: 3 not found
        std::cout &lt;&lt; &quot;3 not found&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</div></li><li class="list__item" id="610e658e_1113"><p id="610e658e_1114"><span class="control" id="610e658e_1115"><code class="code" id="610e658e_1116">std::all_of</code>, <code class="code" id="610e658e_1117">std::any_of</code>, <code class="code" id="610e658e_1118">std::none_of</code>:</span></p><ul class="list _ul" id="610e658e_1119"><li class="list__item" id="610e658e_1120"><p>Check if all, any, or none of the elements in a range satisfy a given condition.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {2, 4, 6, 8, 10};

    // Output: All are even: 1
    std::cout &lt;&lt; &quot;All are even: &quot; &lt;&lt; std::all_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 == 0; }) &lt;&lt; std::endl;

    // Output: Any is odd: 0
    std::cout &lt;&lt; &quot;Any is odd: &quot; &lt;&lt; std::any_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    // Output: None is odd: 1
    std::cout &lt;&lt; &quot;None is odd: &quot; &lt;&lt; std::none_of(numbers.begin(), numbers.end(), [](int x) { return x % 2 != 0; }) &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="610e658e_1122">These examples illustrate the usage of non-modifying sequence operations in the STL, providing various ways to interact with and analyze sequences without altering their content.</p></section><section class="chapter"><h2 id="3-modifying-sequence-operations" data-toc="3-modifying-sequence-operations"   >3. Modifying Sequence Operations</h2><p id="610e658e_1123">Modifying Sequence Operations in C++ STL are a set of algorithms that perform modifications directly on the elements of a sequence (like arrays or containers) in a generic way. These algorithms can be used to manipulate the contents of a range or container. Here are some common modifying sequence operations along with examples:</p><section class="chapter"><h3 id="std-copy" data-toc="std-copy"   >std::copy:</h3><p id="610e658e_1124">The <code class="code" id="610e658e_1125">std::copy</code> algorithm is used to copy elements from one range to another.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; source = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; destination(source.size());

    // Copy elements from source to destination
    std::copy(source.begin(), source.end(), destination.begin());

    // Print the contents of the destination vector
    for (int num : destination) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-transform" data-toc="std-transform"   >std::transform:</h3><p id="610e658e_1127">The <code class="code" id="610e658e_1128">std::transform</code> algorithm applies a specified operation to each element in a range and stores the result in another range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; squared_numbers(numbers.size());

    // Square each element and store the result in squared_numbers
    std::transform(numbers.begin(), numbers.end(), squared_numbers.begin(),
                   [](int x) { return x * x; });

    // Print the squared numbers
    for (int num : squared_numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-remove-and-std-remove-if" data-toc="std-remove-and-std-remove-if"   >std::remove and std::remove_if:</h3><p id="610e658e_1130">These algorithms are used to remove elements from a range based on a specified value or condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Remove all occurrences of the value 2
    auto new_end = std::remove(numbers.begin(), numbers.end(), 2);

    // Resize the container to the new size after removal
    numbers.resize(std::distance(numbers.begin(), new_end));

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="std-replace-and-std-replace-if" data-toc="std-replace-and-std-replace-if"   >std::replace and std::replace_if:</h3><p id="610e658e_1132">These algorithms replace elements in a range with a specified value or based on a condition.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 2, 5, 2};

    // Replace all occurrences of the value 2 with 0
    std::replace(numbers.begin(), numbers.end(), 2, 0);

    // Print the modified vector
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div><p id="610e658e_1134">These examples illustrate the use of modifying sequence operations in the C++ STL to manipulate the contents of sequences or containers.</p></section></section><section class="chapter"><h2 id="4-sorting-and-searching-operations" data-toc="4-sorting-and-searching-operations"   >4. Sorting and Searching Operations</h2><p id="610e658e_1135">Sure, let's delve into Sorting and Searching Operations in C++ using the STL.</p><section class="chapter"><h3 id="sorting-operations" data-toc="sorting-operations"   >Sorting Operations:</h3><section class="chapter"><h4 id="std-sort" data-toc="std-sort"   >std::sort:</h4><p id="610e658e_1136">This algorithm is used to sort elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 7};

    std::sort(numbers.begin(), numbers.end());

    // Output: 1 2 5 7 8
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-stable-sort" data-toc="std-stable-sort"   >std::stable_sort:</h4><p id="610e658e_1138">Similar to <code class="code" id="610e658e_1139">std::sort</code>, but maintains the relative order of equal elements.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;std::pair&lt;int, std::string&gt;&gt; data = {{5, &quot;five&quot;}, {2, &quot;two&quot;}, {8, &quot;eight&quot;}, {1, &quot;one&quot;}, {7, &quot;seven&quot;}};

    std::stable_sort(data.begin(), data.end(), [](const auto&amp; a, const auto&amp; b) {
        return a.first &lt; b.first;
    });

    // Output: (1, &quot;one&quot;) (2, &quot;two&quot;) (5, &quot;five&quot;) (7, &quot;seven&quot;) (8, &quot;eight&quot;)
    for (const auto&amp; pair : data) {
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; pair.first &lt;&lt; &quot;, \&quot;&quot; &lt;&lt; pair.second &lt;&lt; &quot;\&quot;) &quot;;
    }

    return 0;
}
</div></section></section><section class="chapter"><h3 id="searching-operations" data-toc="searching-operations"   >Searching Operations:</h3><section class="chapter"><h4 id="std-binary-search" data-toc="std-binary-search"   >std::binary_search:</h4><p id="610e658e_1141">Performs binary search on a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    bool found = std::binary_search(numbers.begin(), numbers.end(), 5);

    // Output: Found
    if (found) {
        std::cout &lt;&lt; &quot;Found\n&quot;;
    } else {
        std::cout &lt;&lt; &quot;Not Found\n&quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h4 id="std-lower-bound-and-std-upper-bound" data-toc="std-lower-bound-and-std-upper-bound"   >std::lower_bound and std::upper_bound:</h4><p id="610e658e_1143">Find the lower/upper bound of a value in a sorted range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 5, 7, 8};

    auto lower = std::lower_bound(numbers.begin(), numbers.end(), 5);
    auto upper = std::upper_bound(numbers.begin(), numbers.end(), 5);

    // Output: Lower Bound: 5, Upper Bound: 7
    std::cout &lt;&lt; &quot;Lower Bound: &quot; &lt;&lt; *lower &lt;&lt; &quot;, Upper Bound: &quot; &lt;&lt; *upper &lt;&lt; std::endl;

    return 0;
}
</div><p id="610e658e_1145">These examples demonstrate some common sorting and searching operations using the STL in C++. Feel free to experiment with different data types and adapt these examples to your specific use cases.</p></section></section></section><section class="chapter"><h2 id="5-numeric-operations" data-toc="5-numeric-operations"   >5. Numeric Operations</h2><p id="610e658e_1146">Numeric operations in C++ involve various algorithms for performing computations on numerical data. The <code class="code" id="610e658e_1147">&lt;numeric&gt;</code> header in the Standard Template Library (STL) provides several functions that are commonly used for such operations. Here are some key numeric operations along with examples:</p><ol class="list _decimal" id="610e658e_1148" type="1"><li class="list__item" id="610e658e_1149"><p id="610e658e_1150"><span class="control" id="610e658e_1151"><code class="code" id="610e658e_1152">std::accumulate</code></span>: Computes the sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="610e658e_1154"><p id="610e658e_1155"><span class="control" id="610e658e_1156"><code class="code" id="610e658e_1157">std::inner_product</code></span>: Computes the inner product of two ranges.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; a = {1, 2, 3, 4, 5};
    std::vector&lt;int&gt; b = {2, 2, 2, 2, 2};

    int result = std::inner_product(a.begin(), a.end(), b.begin(), 0);

    std::cout &lt;&lt; &quot;Inner Product: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
}
</div></li><li class="list__item" id="610e658e_1159"><p id="610e658e_1160"><span class="control" id="610e658e_1161"><code class="code" id="610e658e_1162">std::partial_sum</code></span>: Computes the partial sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    std::vector&lt;int&gt; partial_sums(numbers.size());
    std::partial_sum(numbers.begin(), numbers.end(), partial_sums.begin());

    std::cout &lt;&lt; &quot;Partial Sums: &quot;;
    for (int value : partial_sums) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div></li></ol><p id="610e658e_1164">These examples demonstrate how to use <code class="code" id="610e658e_1165">std::accumulate</code>, <code class="code" id="610e658e_1166">std::inner_product</code>, and <code class="code" id="610e658e_1167">std::partial_sum</code> to perform common numeric operations. The <code class="code" id="610e658e_1168">&lt;numeric&gt;</code> header provides other functions as well, so it's worth exploring the documentation for additional functionality related to numeric computations in C++.</p></section><section class="chapter"><h2 id="6-containers" data-toc="6-containers"   >6. Containers</h2><p id="610e658e_1169">In C++, containers are objects that hold other objects. They are a crucial part of the Standard Template Library (STL) and provide various ways to store and organize data efficiently. Here are some commonly used containers in C++ along with examples:</p><section class="chapter"><h3 id="1-std-vector" data-toc="1-std-vector"   >1. std::vector</h3><ul class="list _ul" id="610e658e_1170"><li class="list__item" id="610e658e_1171"><p id="610e658e_1172">Dynamic array that can resize itself.</p></li><li class="list__item" id="610e658e_1173"><p id="610e658e_1174">Elements are stored in contiguous memory.</p><div class="code-block" data-lang="cpp"         >
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="2-std-list" data-toc="2-std-list"   >2. std::list</h3><ul class="list _ul" id="610e658e_1176"><li class="list__item" id="610e658e_1177"><p id="610e658e_1178">Doubly-linked list.</p></li><li class="list__item" id="610e658e_1179"><p id="610e658e_1180">Allows constant time insertions and deletions.</p><div class="code-block" data-lang="cpp"         >
#include &lt;list&gt;
#include &lt;iostream&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="3-std-deque" data-toc="3-std-deque"   >3. std::deque</h3><ul class="list _ul" id="610e658e_1182"><li class="list__item" id="610e658e_1183"><p id="610e658e_1184">Double-ended queue.</p></li><li class="list__item" id="610e658e_1185"><p id="610e658e_1186">Similar to vectors but allows efficient insertion/removal at both ends.</p><div class="code-block" data-lang="cpp"         >
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    std::deque&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6);
    numbers.push_front(0);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="4-std-set" data-toc="4-std-set"   >4. std::set</h3><ul class="list _ul" id="610e658e_1188"><li class="list__item" id="610e658e_1189"><p id="610e658e_1190">Sorted associative container (set).</p></li><li class="list__item" id="610e658e_1191"><p id="610e658e_1192">Stores unique elements in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;set&gt;
#include &lt;iostream&gt;

int main() {
    std::set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="5-std-map" data-toc="5-std-map"   >5. std::map</h3><ul class="list _ul" id="610e658e_1194"><li class="list__item" id="610e658e_1195"><p id="610e658e_1196">Sorted associative container (map).</p></li><li class="list__item" id="610e658e_1197"><p id="610e658e_1198">Stores key-value pairs in sorted order.</p><div class="code-block" data-lang="cpp"         >
#include &lt;map&gt;
#include &lt;iostream&gt;

int main() {
    std::map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="6-std-unordered-set" data-toc="6-std-unordered-set"   >6. std::unordered_set</h3><ul class="list _ul" id="610e658e_1200"><li class="list__item" id="610e658e_1201"><p id="610e658e_1202">Unordered associative container (unordered set).</p></li><li class="list__item" id="610e658e_1203"><p id="610e658e_1204">Stores unique elements in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_set&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_set&lt;int&gt; numbers = {5, 2, 8, 1, 7};
    numbers.insert(3);
    numbers.erase(2);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h3 id="7-std-unordered-map" data-toc="7-std-unordered-map"   >7. std::unordered_map</h3><ul class="list _ul" id="610e658e_1206"><li class="list__item" id="610e658e_1207"><p id="610e658e_1208">Unordered associative container (unordered map).</p></li><li class="list__item" id="610e658e_1209"><p id="610e658e_1210">Stores key-value pairs in an unordered fashion for fast access.</p><div class="code-block" data-lang="cpp"         >
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

int main() {
    std::unordered_map&lt;std::string, int&gt; ages = {{&quot;Alice&quot;, 25}, {&quot;Bob&quot;, 30}, {&quot;Charlie&quot;, 22}};
    ages[&quot;David&quot;] = 28;
    ages.erase(&quot;Bob&quot;);

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul><p id="610e658e_1212">These are just a few examples, and C++ provides other containers and variations to suit different needs. The choice of a container depends on the specific requirements of your program, such as the type of operations you need to perform and the performance characteristics you're aiming for.</p></section></section><section class="chapter"><h2 id="7-iterators" data-toc="7-iterators"   >7. Iterators</h2><p id="610e658e_1213">In C++, iterators are used to iterate over the elements of a container (like arrays, vectors, lists, etc.) in a sequential manner. Iterators act as a bridge between the algorithms and the containers, providing a way to access elements without exposing the underlying details of the container's implementation. There are different types of iterators, each with varying capabilities.</p><p id="610e658e_1214">Here are the main types of iterators in C++:</p><section class="chapter"><h3 id="1-input-iterators" data-toc="1-input-iterators"   >1. Input Iterators:</h3><ul class="list _ul" id="610e658e_1215"><li class="list__item" id="610e658e_1216"><p>Allow sequential access to the elements of a container in a forward direction.</p></li><li class="list__item" id="610e658e_1217"><p>Read-only access.</p></li><li class="list__item" id="610e658e_1218"><p>Single-pass, meaning you can traverse the container only once.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using input iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="2-output-iterators" data-toc="2-output-iterators"   >2. Output Iterators:</h3><ul class="list _ul" id="610e658e_1220"><li class="list__item" id="610e658e_1221"><p>Allow sequential access to the elements of a container for writing.</p></li><li class="list__item" id="610e658e_1222"><p>Write-only access.</p></li><li class="list__item" id="610e658e_1223"><p>Single-pass.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers;

    // Example of using output iterators
    for (int i = 1; i &lt;= 5; ++i) {
        numbers.push_back(i);
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="3-forward-iterators" data-toc="3-forward-iterators"   >3. Forward Iterators:</h3><ul class="list _ul" id="610e658e_1225"><li class="list__item" id="610e658e_1226"><p>Allow both reading and writing of elements.</p></li><li class="list__item" id="610e658e_1227"><p>Support multiple passes over the container.</p></li><li class="list__item" id="610e658e_1228"><p>Can be used with algorithms that require bidirectional or random access iterators.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;forward_list&gt;

int main() {
    std::forward_list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using forward iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Modify the elements using the iterator
        *it *= 2;
    }

    // Another example using std::copy to copy elements to the standard output
    std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    return 0;
}
</div></section><section class="chapter"><h3 id="4-bidirectional-iterators" data-toc="4-bidirectional-iterators"   >4. Bidirectional Iterators:</h3><ul class="list _ul" id="610e658e_1230"><li class="list__item" id="610e658e_1231"><p>Support both forward and backward movement.</p></li><li class="list__item" id="610e658e_1232"><p>Used in algorithms that require backward traversal.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using bidirectional iterators
    auto it = numbers.end();
    while (it != numbers.begin()) {
        --it;
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="5-random-access-iterators" data-toc="5-random-access-iterators"   >5. Random Access Iterators:</h3><ul class="list _ul" id="610e658e_1234"><li class="list__item" id="610e658e_1235"><p>Support random access to elements (direct access by index).</p></li><li class="list__item" id="610e658e_1236"><p>Provide efficient movement in both forward and backward directions.</p></li></ul><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};

    // Example of using random access iterators
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        // Access elements using iterator as if it were a pointer
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }

    // Accessing elements directly by index
    std::cout &lt;&lt; &quot;\nThird element: &quot; &lt;&lt; numbers[2];

    return 0;
}
</div><p id="610e658e_1238">Understanding and using iterators is fundamental for working effectively with the C++ Standard Template Library and its algorithms.</p></section></section><section class="chapter"><h2 id="8-allocators" data-toc="8-allocators"   >8. Allocators</h2><p id="610e658e_1239">In C++, allocators are objects responsible for allocating and deallocating memory for containers. They provide a level of abstraction between the container and the memory management system. The <code class="code" id="610e658e_1240">std::allocator</code> is the default allocator provided by the C++ Standard Library, but custom allocators can be implemented to tailor memory management to specific needs.</p><p id="610e658e_1241">Here's a brief explanation of allocators along with an example using <code class="code" id="610e658e_1242">std::allocator</code>:</p><section class="chapter"><h3 id="std-allocator-example" data-toc="std-allocator-example"   >std::allocator Example:</h3><p id="610e658e_1243">The <code class="code" id="610e658e_1244">std::allocator</code> template class is a simple allocator that uses <code class="code" id="610e658e_1245">new</code> and <code class="code" id="610e658e_1246">delete</code> to allocate and deallocate memory. It is the default allocator for most C++ Standard Library containers.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt; // for std::allocator

int main() {
    // Example using std::allocator with std::vector
    std::allocator&lt;int&gt; myAllocator;

    // Allocate memory for an array of 5 integers
    int* data = myAllocator.allocate(5);

    // Initialize the allocated memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.construct(&amp;data[i], i + 1);
    }

    // Use the initialized data
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    // Deallocate the memory
    for (int i = 0; i &lt; 5; ++i) {
        myAllocator.destroy(&amp;data[i]);
    }
    myAllocator.deallocate(data, 5);

    return 0;
}
</div><p id="610e658e_1248">In this example:</p><ul class="list _ul" id="610e658e_1249"><li class="list__item" id="610e658e_1250"><p><code class="code" id="610e658e_1251">myAllocator.allocate(5)</code> allocates memory for an array of 5 integers.</p></li><li class="list__item" id="610e658e_1252"><p><code class="code" id="610e658e_1253">myAllocator.construct(&amp;data[i], i + 1)</code> initializes each element in the allocated memory.</p></li><li class="list__item" id="610e658e_1254"><p><code class="code" id="610e658e_1255">myAllocator.destroy(&amp;data[i])</code> is used to explicitly call the destructor for each element.</p></li><li class="list__item" id="610e658e_1256"><p><code class="code" id="610e658e_1257">myAllocator.deallocate(data, 5)</code> deallocates the memory.</p></li></ul></section><section class="chapter"><h3 id="custom-allocators" data-toc="custom-allocators"   >Custom Allocators:</h3><p id="610e658e_1258">You can create custom allocators by implementing a class that adheres to the allocator interface. The allocator interface typically includes functions like <code class="code" id="610e658e_1259">allocate</code>, <code class="code" id="610e658e_1260">deallocate</code>, <code class="code" id="610e658e_1261">construct</code>, and <code class="code" id="610e658e_1262">destroy</code>.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
struct MyAllocator {
    using value_type = T;

    MyAllocator() = default;

    T* allocate(std::size_t n) {
        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, std::size_t n) {
        ::operator delete(p);
    }

    template &lt;typename... Args&gt;
    void construct(T* p, Args&amp;&amp;... args) {
        new (p) T(std::forward&lt;Args&gt;(args)...);
    }

    void destroy(T* p) {
        p-&gt;~T();
    }
};

int main() {
    // Example using a custom allocator with std::vector
    std::vector&lt;int, MyAllocator&lt;int&gt;&gt; myVector({1, 2, 3, 4, 5});

    for (const auto&amp; value : myVector) {
        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}
</div><p id="610e658e_1264">In this example, <code class="code" id="610e658e_1265">MyAllocator</code> is a simple custom allocator that uses <code class="code" id="610e658e_1266">operator new</code> and <code class="code" id="610e658e_1267">operator delete</code> for memory management. The <code class="code" id="610e658e_1268">std::vector</code> is then instantiated with this custom allocator.</p></section></section><div class="last-modified"> Last modified: 23 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="templates-and-template-metaprogramming.html">Templates and Template Metaprogramming</a>   <a class="navigation-links__next" href="string-type.html">String type</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>