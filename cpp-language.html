<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-23T13:33:12.0251593"><meta name="build-number" content="${buildNumber}">       <title>Cpp Language | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-templates-and-template-metaprogramming","level":0,"title":"2. Templates and Template Metaprogramming","anchor":"#2-templates-and-template-metaprogramming"},{"id":"3-smart-pointers","level":0,"title":"3. Smart Pointers","anchor":"#3-smart-pointers"},{"id":"4-move-semantics-and-rvalue-references","level":0,"title":"4. Move Semantics and Rvalue References","anchor":"#4-move-semantics-and-rvalue-references"},{"id":"5-lambda-expressions","level":0,"title":"5. Lambda Expressions","anchor":"#5-lambda-expressions"},{"id":"6-concurrency-and-multithreading","level":0,"title":"6. Concurrency and Multithreading","anchor":"#6-concurrency-and-multithreading"},{"id":"7-stl-algorithms-and-data-structures","level":0,"title":"7. STL Algorithms and Data Structures","anchor":"#7-stl-algorithms-and-data-structures"},{"id":"8-variadic-templates","level":0,"title":"8. Variadic Templates","anchor":"#8-variadic-templates"},{"id":"9-type-traits-and-sfinae","level":0,"title":"9. Type Traits and SFINAE","anchor":"#9-type-traits-and-sfinae"},{"id":"10-raii-resource-acquisition-is-initialization","level":0,"title":"10. RAII (Resource Acquisition Is Initialization)","anchor":"#10-raii-resource-acquisition-is-initialization"},{"id":"11-custom-memory-allocators","level":0,"title":"11. Custom Memory Allocators","anchor":"#11-custom-memory-allocators"},{"id":"12-crtp-curiously-recurring-template-pattern","level":0,"title":"12. CRTP (Curiously Recurring Template Pattern)","anchor":"#12-crtp-curiously-recurring-template-pattern"},{"id":"13-c-concepts-since-c-20","level":0,"title":"13. C++ Concepts (since C++20)","anchor":"#13-c-concepts-since-c-20"},{"id":"14-user-defined-literals","level":0,"title":"14. User-Defined Literals","anchor":"#14-user-defined-literals"},{"id":"15-expression-templates","level":0,"title":"15. Expression Templates","anchor":"#15-expression-templates"},{"id":"16-aspect-oriented-programming-aop","level":0,"title":"16. Aspect-Oriented Programming (AOP)","anchor":"#16-aspect-oriented-programming-aop"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Cpp Language | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="cpp-language.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Cpp Language | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "cpp-language.html#webpage", "url": "cpp-language.html", "name": "Cpp Language | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="Cpp-Language" data-main-title="Cpp Language" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs=""  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Cpp-Language"   id="Cpp-Language.md">Cpp Language</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><section class="chapter"><h3 id="what-is-c" data-toc="what-is-c"   >What is C++?</h3><ul class="list _ul" id="dbdcea33_683"><li class="list__item" id="dbdcea33_684"><p>C++ is a cross-platform language that can be used to create high-performance applications.</p></li><li class="list__item" id="dbdcea33_685"><p>C++ was developed by Bjarne Stroustrup, as an extension to the C language.</p></li><li class="list__item" id="dbdcea33_686"><p>C++ gives programmers a high level of control over system resources and memory.</p></li><li class="list__item" id="dbdcea33_687"><p>The language was updated 4 major times in 2011, 2014, 2017, and 2020 to C++11, C++14, C++17, C++20.</p></li></ul></section><section class="chapter"><h3 id="why-use-c" data-toc="why-use-c"   >Why Use C++</h3><ul class="list _ul" id="dbdcea33_688"><li class="list__item" id="dbdcea33_689"><p>C++ is one of the world's most popular programming languages.</p></li><li class="list__item" id="dbdcea33_690"><p>C++ can be found in today's operating systems, Graphical User Interfaces, and embedded systems.</p></li><li class="list__item" id="dbdcea33_691"><p>C++ is an object-oriented programming language which gives a clear structure to programs and allows code to be reused, lowering development costs.</p></li><li class="list__item" id="dbdcea33_692"><p>C++ is portable and can be used to develop applications that can be adapted to multiple platforms.</p></li><li class="list__item" id="dbdcea33_693"><p>C++ is fun and easy to learn!</p></li><li class="list__item" id="dbdcea33_694"><p>As C++ is close to C, C# and Java, it makes it easy for programmers to switch to C++ or vice versa.</p></li></ul></section></section><section class="chapter"><h2 id="2-templates-and-template-metaprogramming" data-toc="2-templates-and-template-metaprogramming"   >2. Templates and Template Metaprogramming</h2><p id="dbdcea33_695">Templates in C++ provide a way to write generic code that can work with different data types. Template metaprogramming, on the other hand, involves using templates to perform computations at compile-time. Here, I'll provide a brief explanation of templates and then delve into an example of template metaprogramming.</p><section class="chapter"><h3 id="templates" data-toc="templates"   >Templates:</h3><section class="chapter"><h4 id="function-templates" data-toc="function-templates"   >Function Templates:</h4><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

// A simple function template that swaps two values of any type.
template &lt;typename T&gt;
void swapValues(T &amp;a, T &amp;b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int int1 = 5, int2 = 10;
    std::cout &lt;&lt; &quot;Before swap: &quot; &lt;&lt; int1 &lt;&lt; &quot;, &quot; &lt;&lt; int2 &lt;&lt; std::endl;

    // Using the function template with int type.
    swapValues(int1, int2);

    std::cout &lt;&lt; &quot;After swap: &quot; &lt;&lt; int1 &lt;&lt; &quot;, &quot; &lt;&lt; int2 &lt;&lt; std::endl;

    double double1 = 3.14, double2 = 6.28;
    std::cout &lt;&lt; &quot;Before swap: &quot; &lt;&lt; double1 &lt;&lt; &quot;, &quot; &lt;&lt; double2 &lt;&lt; std::endl;

    // Using the same function template with double type.
    swapValues(double1, double2);

    std::cout &lt;&lt; &quot;After swap: &quot; &lt;&lt; double1 &lt;&lt; &quot;, &quot; &lt;&lt; double2 &lt;&lt; std::endl;

    return 0;
}
</div></section><section class="chapter"><h4 id="class-templates" data-toc="class-templates"   >Class Templates:</h4><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

// A simple class template for a pair of values.
template &lt;typename T1, typename T2&gt;
class Pair {
public:
    T1 first;
    T2 second;

    Pair(const T1&amp; f, const T2&amp; s) : first(f), second(s) {}
};

int main() {
    // Using the class template with int and double types.
    Pair&lt;int, double&gt; myPair(5, 3.14);

    std::cout &lt;&lt; &quot;Pair values: &quot; &lt;&lt; myPair.first &lt;&lt; &quot;, &quot; &lt;&lt; myPair.second &lt;&lt; std::endl;

    return 0;
}
</div></section></section><section class="chapter"><h3 id="template-metaprogramming" data-toc="template-metaprogramming"   >Template Metaprogramming:</h3><p id="dbdcea33_698">Template metaprogramming involves using templates to perform computations at compile-time. One classic example is calculating the factorial of a number at compile-time using recursion.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

// Primary template for factorial calculation.
template &lt;int N&gt;
struct Factorial {
    static const int value = N * Factorial&lt;N - 1&gt;::value;
};

// Specialization to end the recursion for Factorial&lt;0&gt;.
template &lt;&gt;
struct Factorial&lt;0&gt; {
    static const int value = 1;
};

int main() {
    const int result = Factorial&lt;5&gt;::value;  // Compile-time calculation of factorial.

    std::cout &lt;&lt; &quot;Factorial of 5 is: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
}
</div><p id="dbdcea33_700">In this example, the <code class="code" id="dbdcea33_701">Factorial</code> template is specialized for the case where <code class="code" id="dbdcea33_702">N</code> is 0, providing a base case for recursion. The recursive nature of template instantiation allows the compiler to calculate the factorial at compile-time. This is a basic example of template metaprogramming, and more complex examples can involve conditional compilation, type deduction, and other advanced techniques.</p></section></section><section class="chapter"><h2 id="3-smart-pointers" data-toc="3-smart-pointers"   >3. Smart Pointers</h2><p id="dbdcea33_703">Smart pointers in C++ are objects that act like pointers but provide additional features such as automatic memory management. They are part of the C++ Standard Library and help in preventing memory leaks and making the code more robust. Here, I'll explain two types of smart pointers: <code class="code" id="dbdcea33_704">std::unique_ptr</code> and <code class="code" id="dbdcea33_705">std::shared_ptr</code>.</p><section class="chapter"><h3 id="std-unique-ptr-example" data-toc="std-unique-ptr-example"   >std::unique_ptr Example:</h3><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;memory&gt;

class MyClass {
public:
    MyClass() {
        std::cout &lt;&lt; &quot;MyClass Constructor\n&quot;;
    }

    void Display() const {
        std::cout &lt;&lt; &quot;Displaying MyClass\n&quot;;
    }

    ~MyClass() {
        std::cout &lt;&lt; &quot;MyClass Destructor\n&quot;;
    }
};

int main() {
    // Creating a unique_ptr
    std::unique_ptr&lt;MyClass&gt; uniquePtr = std::make_unique&lt;MyClass&gt;();

    // Accessing the object using the unique_ptr
    uniquePtr-&gt;Display();

    // unique_ptr automatically releases memory when it goes out of scope
    return 0; // uniquePtr is destroyed, MyClass Destructor is called
}
</div><p id="dbdcea33_707">In this example, <code class="code" id="dbdcea33_708">std::unique_ptr</code> is used to manage an instance of <code class="code" id="dbdcea33_709">MyClass</code>. The memory allocated for <code class="code" id="dbdcea33_710">MyClass</code> is automatically released when the <code class="code" id="dbdcea33_711">std::unique_ptr</code> goes out of scope.</p></section><section class="chapter"><h3 id="std-shared-ptr-example" data-toc="std-shared-ptr-example"   >std::shared_ptr Example:</h3><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;memory&gt;

class MyClass {
public:
    MyClass() {
        std::cout &lt;&lt; &quot;MyClass Constructor\n&quot;;
    }

    void Display() const {
        std::cout &lt;&lt; &quot;Displaying MyClass\n&quot;;
    }

    ~MyClass() {
        std::cout &lt;&lt; &quot;MyClass Destructor\n&quot;;
    }
};

int main() {
    // Creating a shared_ptr with make_shared
    std::shared_ptr&lt;MyClass&gt; sharedPtr = std::make_shared&lt;MyClass&gt;();

    // Creating another shared_ptr pointing to the same object
    std::shared_ptr&lt;MyClass&gt; sharedPtr2 = sharedPtr;

    // Accessing the object using the shared_ptr
    sharedPtr-&gt;Display();
    sharedPtr2-&gt;Display();

    // shared_ptr automatically manages memory and keeps track of the number of references
    return 0; // sharedPtr and sharedPtr2 are destroyed, MyClass Destructor is called
}
</div><p id="dbdcea33_713">In this example, <code class="code" id="dbdcea33_714">std::shared_ptr</code> is used to manage an instance of <code class="code" id="dbdcea33_715">MyClass</code>. The <code class="code" id="dbdcea33_716">sharedPtr</code> and <code class="code" id="dbdcea33_717">sharedPtr2</code> both point to the same object, and the memory is automatically released when the last <code class="code" id="dbdcea33_718">shared_ptr</code> referencing the object is destroyed.</p><p id="dbdcea33_719">These smart pointers handle memory management automatically, reducing the chances of memory leaks and making it easier to write correct and safe C++ code.</p></section></section><section class="chapter"><h2 id="4-move-semantics-and-rvalue-references" data-toc="4-move-semantics-and-rvalue-references"   >4. Move Semantics and Rvalue References</h2><p id="dbdcea33_720">Move semantics and rvalue references in C++ allow for more efficient resource management by enabling the transfer of ownership from one object to another without unnecessary copying. Here's an explanation with examples:</p><section class="chapter"><h3 id="rvalue-references" data-toc="rvalue-references"   >Rvalue References:</h3><p id="dbdcea33_721">Rvalue references are a type of reference introduced in C++11, denoted by <code class="code" id="dbdcea33_722">&amp;&amp;</code>. They allow you to bind to temporary objects (rvalues) and are commonly used in the implementation of move semantics.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

void processValue(int &amp;&amp;val) {
    // Do something with the temporary value
    std::cout &lt;&lt; &quot;Received value: &quot; &lt;&lt; val &lt;&lt; std::endl;
}

int main() {
    // Create a temporary integer (rvalue)
    int tempValue = 42;

    // Bind the rvalue to an rvalue reference
    processValue(std::move(tempValue));

    // Note: tempValue should not be used after std::move, as its state is moved
    // std::cout &lt;&lt; &quot;After move: &quot; &lt;&lt; tempValue &lt;&lt; std::endl; // Error!

    return 0;
}
</div><p id="dbdcea33_724">In this example, <code class="code" id="dbdcea33_725">processValue</code> takes an rvalue reference as its parameter. The <code class="code" id="dbdcea33_726">std::move</code> function is used to cast <code class="code" id="dbdcea33_727">tempValue</code> to an rvalue, allowing it to be passed to the function. After the move, <code class="code" id="dbdcea33_728">tempValue</code> should not be used, as its state has been transferred.</p></section><section class="chapter"><h3 id="move-semantics" data-toc="move-semantics"   >Move Semantics:</h3><p id="dbdcea33_729">Move semantics involve efficiently transferring resources (like dynamically allocated memory) from one object to another, avoiding unnecessary copying. This is particularly useful for objects with expensive-to-copy contents.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;utility&gt;

class MyString {
private:
    char* data;

public:
    // Constructor
    MyString(const char* str) {
        std::cout &lt;&lt; &quot;Constructor called!&quot; &lt;&lt; std::endl;
        // Allocate memory and copy the string
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // Move constructor (takes an rvalue reference)
    MyString(MyString&amp;&amp; other) noexcept {
        std::cout &lt;&lt; &quot;Move constructor called!&quot; &lt;&lt; std::endl;
        // Transfer ownership of the data
        data = other.data;
        other.data = nullptr;  // Ensure the source object is in a valid state
    }

    // Destructor
    ~MyString() {
        std::cout &lt;&lt; &quot;Destructor called!&quot; &lt;&lt; std::endl;
        delete[] data;
    }

    // Other member functions...

    // Move assignment operator
    MyString&amp; operator=(MyString&amp;&amp; other) noexcept {
        std::cout &lt;&lt; &quot;Move assignment operator called!&quot; &lt;&lt; std::endl;
        if (this != &amp;other) {
            // Release the current data
            delete[] data;

            // Transfer ownership of the data
            data = other.data;
            other.data = nullptr;  // Ensure the source object is in a valid state
        }
        return *this;
    }
};

int main() {
    MyString str1(&quot;Hello, World!&quot;);

    // Use the move constructor
    MyString str2 = std::move(str1);

    // Use the move assignment operator
    MyString str3(&quot;Another string&quot;);
    str3 = std::move(str2);

    return 0;
}
</div><p id="dbdcea33_731">In this example, <code class="code" id="dbdcea33_732">MyString</code> is a simple class managing a dynamically allocated character array. The move constructor and move assignment operator are explicitly defined to transfer ownership of the data from one object to another efficiently. The <code class="code" id="dbdcea33_733">std::move</code> function is used to indicate that a move operation is desired.</p></section></section><section class="chapter"><h2 id="5-lambda-expressions" data-toc="5-lambda-expressions"   >5. Lambda Expressions</h2><p id="dbdcea33_734">Lambda expressions in C++ provide a concise way to define anonymous functions (also known as lambda functions) inline. They are especially useful when you need a short function for a specific task, such as passing a function as an argument to another function. Lambda expressions were introduced in C++11 and have since become a popular feature. Here's a simple explanation with an example:</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

int main() {
    // Example 1: Basic lambda expression
    auto add = [](int a, int b) {
        return a + b;
    };

    int result = add(3, 4);
    std::cout &lt;&lt; &quot;Result of add: &quot; &lt;&lt; result &lt;&lt; std::endl;

    // Example 2: Lambda with capture clause
    int x = 10;
    auto incrementByX = [x](int y) {
        return x + y;
    };

    int newResult = incrementByX(5);
    std::cout &lt;&lt; &quot;Result of incrementByX: &quot; &lt;&lt; newResult &lt;&lt; std::endl;

    // Example 3: Mutable lambda with capture clause
    int counter = 0;
    auto incrementAndPrint = [counter]() mutable {
        std::cout &lt;&lt; &quot;Counter before increment: &quot; &lt;&lt; counter &lt;&lt; std::endl;
        counter++;
        std::cout &lt;&lt; &quot;Counter after increment: &quot; &lt;&lt; counter &lt;&lt; std::endl;
    };

    incrementAndPrint();  // Counter before increment: 0, Counter after increment: 1
    incrementAndPrint();  // Counter before increment: 0, Counter after increment: 1 (counter is mutable)

    return 0;
}
</div><p id="dbdcea33_736">In the first example, a lambda function <code class="code" id="dbdcea33_737">add</code> is defined to take two integers and return their sum. The <code class="code" id="dbdcea33_738">auto</code> keyword is used to let the compiler infer the lambda's return type.</p><p id="dbdcea33_739">In the second example, a lambda function <code class="code" id="dbdcea33_740">incrementByX</code> captures the variable <code class="code" id="dbdcea33_741">x</code> from the enclosing scope. The lambda adds the captured value <code class="code" id="dbdcea33_742">x</code> to its parameter and returns the result.</p><p id="dbdcea33_743">In the third example, a mutable lambda function <code class="code" id="dbdcea33_744">incrementAndPrint</code> captures the variable <code class="code" id="dbdcea33_745">counter</code> by value. The <code class="code" id="dbdcea33_746">mutable</code> keyword allows the lambda to modify the captured variable. Each time the lambda is called, it prints the current value of <code class="code" id="dbdcea33_747">counter</code>, increments it, and prints the updated value.</p><p id="dbdcea33_748">Lambda expressions are powerful and versatile, allowing you to create concise and localized functions in your code. They are commonly used in algorithms, functional programming, and situations where a short-lived function is needed.</p></section><section class="chapter"><h2 id="6-concurrency-and-multithreading" data-toc="6-concurrency-and-multithreading"   >6. Concurrency and Multithreading</h2><p id="dbdcea33_749">Concurrency and multithreading involve the execution of multiple threads concurrently within a program. A thread is a basic unit of execution, and concurrency allows multiple threads to run independently, potentially in parallel. Here's an explanation with an example in C++ using the standard library (<code class="code" id="dbdcea33_750">&lt;thread&gt;</code> and <code class="code" id="dbdcea33_751">&lt;iostream&gt;</code>).</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

// Function to be executed by each thread
void printNumbers(int start, int end) {
    for (int i = start; i &lt;= end; ++i) {
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    }
}

int main() {
    // Define the range of numbers
    int rangeStart = 1;
    int rangeEnd = 10;

    // Create two threads and assign the work
    std::thread t1(printNumbers, rangeStart, rangeEnd / 2);
    std::thread t2(printNumbers, (rangeEnd / 2) + 1, rangeEnd);

    // Wait for both threads to finish
    t1.join();
    t2.join();

    // Output: 1 2 3 4 5 6 7 8 9 10
    std::cout &lt;&lt; &quot;Printing complete.&quot; &lt;&lt; std::endl;

    return 0;
}
</div><p id="dbdcea33_753">In this example, we have a simple program that prints numbers from a given range using two threads. Here's a breakdown of the key concepts:</p><ol class="list _decimal" id="dbdcea33_754" type="1"><li class="list__item" id="dbdcea33_755"><p id="dbdcea33_756"><span class="control" id="dbdcea33_757">Function for Each Thread (<code class="code" id="dbdcea33_758">printNumbers</code>):</span></p><ul class="list _ul" id="dbdcea33_759"><li class="list__item" id="dbdcea33_760"><p>The function <code class="code" id="dbdcea33_761">printNumbers</code> is the task that each thread will execute. It takes a range of numbers and prints them.</p></li></ul></li><li class="list__item" id="dbdcea33_762"><p id="dbdcea33_763"><span class="control" id="dbdcea33_764">Thread Creation:</span></p><ul class="list _ul" id="dbdcea33_765"><li class="list__item" id="dbdcea33_766"><p>Two threads, <code class="code" id="dbdcea33_767">t1</code> and <code class="code" id="dbdcea33_768">t2</code>, are created using the <code class="code" id="dbdcea33_769">std::thread</code> constructor. Each thread is assigned the task of printing a portion of the numbers.</p></li></ul></li><li class="list__item" id="dbdcea33_770"><p id="dbdcea33_771"><span class="control" id="dbdcea33_772">Thread Execution:</span></p><ul class="list _ul" id="dbdcea33_773"><li class="list__item" id="dbdcea33_774"><p>Threads execute concurrently, meaning they may run in parallel on multi-core systems. They each handle a part of the range independently.</p></li></ul></li><li class="list__item" id="dbdcea33_775"><p id="dbdcea33_776"><span class="control" id="dbdcea33_777">Thread Joining:</span></p><ul class="list _ul" id="dbdcea33_778"><li class="list__item" id="dbdcea33_779"><p><code class="code" id="dbdcea33_780">t1.join()</code> and <code class="code" id="dbdcea33_781">t2.join()</code> are used to wait for the threads to finish their execution before proceeding with the main thread. This ensures that the main thread doesn't exit before the threads complete their work.</p></li></ul></li><li class="list__item" id="dbdcea33_782"><p id="dbdcea33_783"><span class="control" id="dbdcea33_784">Output:</span></p><ul class="list _ul" id="dbdcea33_785"><li class="list__item" id="dbdcea33_786"><p>Once both threads finish their work, the main thread outputs a message indicating that the printing is complete.</p></li></ul></li></ol><p id="dbdcea33_787">Concurrency and multithreading are crucial for improving program performance, especially in scenarios where tasks can be parallelized. However, it's important to be cautious about potential race conditions and to use synchronization mechanisms like mutexes (<code class="code" id="dbdcea33_788">std::mutex</code>) and locks (<code class="code" id="dbdcea33_789">std::lock_guard</code>) to ensure data integrity when multiple threads access shared resources.</p></section><section class="chapter"><h2 id="7-stl-algorithms-and-data-structures" data-toc="7-stl-algorithms-and-data-structures"   >7. STL Algorithms and Data Structures</h2><p id="dbdcea33_790">Sure, let's explore some commonly used STL (Standard Template Library) algorithms and data structures with examples:</p><section class="chapter"><h3 id="stl-algorithms" data-toc="stl-algorithms"   >STL Algorithms:</h3><section class="chapter"><h4 id="1-std-sort" data-toc="1-std-sort"   >1. std::sort</h4><ul class="list _ul" id="dbdcea33_791"><li class="list__item" id="dbdcea33_792"><p id="dbdcea33_793">Sorts elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 6};
    std::sort(numbers.begin(), numbers.end());

    for (const auto&amp; num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h4 id="2-std-find" data-toc="2-std-find"   >2. std::find</h4><ul class="list _ul" id="dbdcea33_795"><li class="list__item" id="dbdcea33_796"><p id="dbdcea33_797">Finds the first occurrence of a value in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 6};
    auto it = std::find(numbers.begin(), numbers.end(), 8);

    if (it != numbers.end()) {
        std::cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Not Found&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h4 id="3-std-for-each" data-toc="3-std-for-each"   >3. std::for_each</h4><ul class="list _ul" id="dbdcea33_799"><li class="list__item" id="dbdcea33_800"><p id="dbdcea33_801">Applies a function to each element in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

void printSquare(int num) {
    std::cout &lt;&lt; num * num &lt;&lt; &quot; &quot;;
}

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 6};
    std::for_each(numbers.begin(), numbers.end(), printSquare);

    return 0;
}
</div></li></ul></section><section class="chapter"><h4 id="4-std-accumulate" data-toc="4-std-accumulate"   >4. std::accumulate</h4><ul class="list _ul" id="dbdcea33_803"><li class="list__item" id="dbdcea33_804"><p id="dbdcea33_805">Computes the sum of elements in a range.</p><div class="code-block" data-lang="cpp"         >
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 6};
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</div></li></ul></section></section><section class="chapter"><h3 id="stl-data-structures" data-toc="stl-data-structures"   >STL Data Structures:</h3><section class="chapter"><h4 id="1-std-vector" data-toc="1-std-vector"   >1. std::vector</h4><ul class="list _ul" id="dbdcea33_807"><li class="list__item" id="dbdcea33_808"><p id="dbdcea33_809">Dynamic array that can grow or shrink.</p><div class="code-block" data-lang="cpp"         >
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 6};
    numbers.push_back(10);

    for (const auto&amp; num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h4 id="2-std-map" data-toc="2-std-map"   >2. std::map</h4><ul class="list _ul" id="dbdcea33_811"><li class="list__item" id="dbdcea33_812"><p id="dbdcea33_813">Associative container with key-value pairs.</p><div class="code-block" data-lang="cpp"         >
#include &lt;map&gt;
#include &lt;iostream&gt;

int main() {
    std::map&lt;std::string, int&gt; ages = {
        {&quot;Alice&quot;, 25},
        {&quot;Bob&quot;, 30},
        {&quot;Charlie&quot;, 22}
    };

    for (const auto&amp; entry : ages) {
        std::cout &lt;&lt; entry.first &lt;&lt; &quot;: &quot; &lt;&lt; entry.second &lt;&lt; std::endl;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h4 id="3-std" data-toc="3-std"   >3. std:</h4><ul class="list _ul" id="dbdcea33_815"><li class="list__item" id="dbdcea33_816"><p id="dbdcea33_817">Sorted container of unique elements.</p><div class="code-block" data-lang="cpp"         >
#include &lt;set&gt;
#include &lt;iostream&gt;

int main() {
    std::set&lt;int&gt; uniqueNumbers = {5, 2, 8, 1, 6, 2};

    for (const auto&amp; num : uniqueNumbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</div></li></ul></section><section class="chapter"><h4 id="4-std" data-toc="4-std"   >4. std:</h4><ul class="list _ul" id="dbdcea33_819"><li class="list__item" id="dbdcea33_820"><p id="dbdcea33_821">FIFO (First-In-First-Out) data structure.</p><div class="code-block" data-lang="cpp"         >
#include &lt;queue&gt;
#include &lt;iostream&gt;

int main() {
    std::queue&lt;int&gt; myQueue;
    myQueue.push(10);
    myQueue.push(20);
    myQueue.push(30);

    while (!myQueue.empty()) {
        std::cout &lt;&lt; myQueue.front() &lt;&lt; &quot; &quot;;
        myQueue.pop();
    }

    return 0;
}
</div></li></ul><p id="dbdcea33_823">These examples showcase the use of various algorithms and data structures provided by the C++ STL. Feel free to experiment with them and explore the extensive capabilities of the Standard Template Library.</p></section></section></section><section class="chapter"><h2 id="8-variadic-templates" data-toc="8-variadic-templates"   >8. Variadic Templates</h2><p id="dbdcea33_824">Variadic templates are a feature in C++ that allow you to write functions and classes that take a variable number of arguments. This is particularly useful when you want to create flexible and generic code. The syntax for variadic templates involves the use of ellipsis (<code class="code" id="dbdcea33_825">...</code>) and recursion.</p><p id="dbdcea33_826">Here's a simple example of a variadic template function that prints a variable number of arguments:</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

// Base case for recursion: print nothing
void printArgs() {}

// Recursive case: print the first argument and call printArgs with the remaining arguments
template &lt;typename T, typename... Args&gt;
void printArgs(T first, Args... rest) {
    std::cout &lt;&lt; first &lt;&lt; ' ';
    printArgs(rest...);
}

int main() {
    printArgs(1, 2.5, &quot;Hello&quot;, 'a');
    return 0;
}
</div><p id="dbdcea33_828">In this example, <code class="code" id="dbdcea33_829">printArgs</code> is a variadic template function. The base case is when there are no more arguments (<code class="code" id="dbdcea33_830">void printArgs()</code>), and the recursive case is when there is at least one argument (<code class="code" id="dbdcea33_831">template &lt;typename T, typename... Args&gt;</code>). The function prints the first argument (<code class="code" id="dbdcea33_832">std::cout &lt;&lt; first &lt;&lt; ' ';</code>) and then recursively calls itself with the remaining arguments (<code class="code" id="dbdcea33_833">printArgs(rest...);</code>).</p><p id="dbdcea33_834">When you run this program, it will output:</p><div class="code-block" data-lang="none"         >
1 2.5 Hello a
</div><p id="dbdcea33_836">Here's a breakdown of how it works:</p><ul class="list _ul" id="dbdcea33_837"><li class="list__item" id="dbdcea33_838"><p>The first call to <code class="code" id="dbdcea33_839">printArgs</code> receives four arguments: <code class="code" id="dbdcea33_840">1</code>, <code class="code" id="dbdcea33_841">2.5</code>, <code class="code" id="dbdcea33_842">&quot;Hello&quot;</code>, and <code class="code" id="dbdcea33_843">'a'</code>.</p></li><li class="list__item" id="dbdcea33_844"><p>The function prints <code class="code" id="dbdcea33_845">1</code> and then calls itself with the remaining arguments (<code class="code" id="dbdcea33_846">2.5</code>, <code class="code" id="dbdcea33_847">&quot;Hello&quot;</code>, <code class="code" id="dbdcea33_848">'a'</code>).</p></li><li class="list__item" id="dbdcea33_849"><p>In the second call, it prints <code class="code" id="dbdcea33_850">2.5</code> and calls itself with the remaining arguments (<code class="code" id="dbdcea33_851">&quot;Hello&quot;</code>, <code class="code" id="dbdcea33_852">'a'</code>).</p></li><li class="list__item" id="dbdcea33_853"><p>This process repeats until there are no more arguments, and the base case is reached, terminating the recursion.</p></li></ul><p id="dbdcea33_854">Variadic templates are powerful and are commonly used in libraries and frameworks to create generic and flexible code. They enable you to work with an arbitrary number of arguments while maintaining type safety.</p></section><section class="chapter"><h2 id="9-type-traits-and-sfinae" data-toc="9-type-traits-and-sfinae"   >9. Type Traits and SFINAE</h2><p id="dbdcea33_855"><span class="control" id="dbdcea33_856">Type Traits:</span></p><p id="dbdcea33_857">Type traits are a way to obtain information about types at compile-time. They are implemented using templates and are particularly useful for generic programming. The <code class="code" id="dbdcea33_858">&lt;type_traits&gt;</code> header in C++ provides a collection of type traits.</p><p id="dbdcea33_859">Here is an example of a simple type trait to check whether a type is an integer type:</p><div class="code-block" data-lang="cpp"         >
#include &lt;type_traits&gt;
#include &lt;iostream&gt;

template &lt;typename T&gt;
struct IsInteger {
    static constexpr bool value = std::is_integral&lt;T&gt;::value;
};

int main() {
    std::cout &lt;&lt; std::boolalpha; // Print 'true' or 'false' instead of '1' or '0'

    std::cout &lt;&lt; IsInteger&lt;int&gt;::value &lt;&lt; std::endl;       // true
    std::cout &lt;&lt; IsInteger&lt;float&gt;::value &lt;&lt; std::endl;     // false
    std::cout &lt;&lt; IsInteger&lt;std::string&gt;::value &lt;&lt; std::endl; // false

    return 0;
}
</div><p id="dbdcea33_861">In this example, the <code class="code" id="dbdcea33_862">IsInteger</code> trait uses <code class="code" id="dbdcea33_863">std::is_integral</code> from <code class="code" id="dbdcea33_864">&lt;type_traits&gt;</code> to determine whether the given type <code class="code" id="dbdcea33_865">T</code> is an integer type. The <code class="code" id="dbdcea33_866">value</code> member of the trait is <code class="code" id="dbdcea33_867">true</code> if <code class="code" id="dbdcea33_868">T</code> is an integer type, and <code class="code" id="dbdcea33_869">false</code> otherwise.</p><p id="dbdcea33_870"><span class="control" id="dbdcea33_871">SFINAE (Substitution Failure Is Not An Error):</span></p><p id="dbdcea33_872">SFINAE is a mechanism in C++ that allows the compiler to discard certain template instantiations that would normally result in a compilation error. Instead of producing an error, the compiler simply removes the problematic instantiation from the set of candidates.</p><p id="dbdcea33_873">Here's an example using SFINAE to enable a function template only for types with a nested <code class="code" id="dbdcea33_874">value_type</code>:</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template &lt;typename T&gt;
struct HasValueType {
    // SFINAE: This overload is only considered if T has a nested 'value_type'.
    template &lt;typename U = T&gt;
    static std::true_type test(decltype(U::value_type)*);

    // SFINAE: This overload is considered for any other type.
    static std::false_type test(...);

    // 'value' member is true if T has a nested 'value_type', false otherwise.
    static constexpr bool value = decltype(test(nullptr))::value;
};

int main() {
    std::cout &lt;&lt; std::boolalpha;

    std::cout &lt;&lt; HasValueType&lt;int&gt;::value &lt;&lt; std::endl;       // false
    std::cout &lt;&lt; HasValueType&lt;double&gt;::value &lt;&lt; std::endl;    // false
    std::cout &lt;&lt; HasValueType&lt;std::vector&lt;int&gt;&gt;::value &lt;&lt; std::endl; // true

    return 0;
}
</div><p id="dbdcea33_876">In this example, the <code class="code" id="dbdcea33_877">HasValueType</code> trait checks whether a type <code class="code" id="dbdcea33_878">T</code> has a nested <code class="code" id="dbdcea33_879">value_type</code>. The SFINAE technique is used to define two overloads of the <code class="code" id="dbdcea33_880">test</code> function. The first overload is selected only if <code class="code" id="dbdcea33_881">T</code> has a nested <code class="code" id="dbdcea33_882">value_type</code>, and the second overload is a catch-all that will be selected otherwise. The <code class="code" id="dbdcea33_883">value</code> member of the trait is <code class="code" id="dbdcea33_884">true</code> if <code class="code" id="dbdcea33_885">T</code> has <code class="code" id="dbdcea33_886">value_type</code>, and <code class="code" id="dbdcea33_887">false</code> otherwise.</p></section><section class="chapter"><h2 id="10-raii-resource-acquisition-is-initialization" data-toc="10-raii-resource-acquisition-is-initialization"   >10. RAII (Resource Acquisition Is Initialization)</h2><p id="dbdcea33_888">RAII, or Resource Acquisition Is Initialization, is a C++ programming idiom that ties the lifecycle of a resource to the scope of an object. The idea is to ensure that resource allocation and deallocation are handled automatically by tying them to the object's constructor and destructor, respectively. This helps in preventing resource leaks and simplifying resource management.</p><p id="dbdcea33_889">Let's look at a simple example to illustrate RAII. Suppose we have a class <code class="code" id="dbdcea33_890">FileHandler</code> that manages the opening and closing of a file:</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

class FileHandler {
public:
    // Constructor: Opens the file
    FileHandler(const std::string&amp; filename) : file(filename) {
        if (!file.is_open()) {
            std::cerr &lt;&lt; &quot;Error: Could not open file &quot; &lt;&lt; filename &lt;&lt; std::endl;
            // You might throw an exception or handle the error in some way
        }
        else {
            std::cout &lt;&lt; &quot;File &quot; &lt;&lt; filename &lt;&lt; &quot; opened successfully.&quot; &lt;&lt; std::endl;
        }
    }

    // Destructor: Closes the file
    ~FileHandler() {
        if (file.is_open()) {
            file.close();
            std::cout &lt;&lt; &quot;File closed.&quot; &lt;&lt; std::endl;
        }
    }

    // Other methods for reading, writing, etc.

private:
    std::ifstream file; // File stream for input operations
};

int main() {
    // Example usage of FileHandler with RAII
    FileHandler fileReader(&quot;example.txt&quot;);

    // Perform operations on the file using fileReader...

    // File is automatically closed when fileReader goes out of scope
    // (e.g., at the end of the main function or in case of an exception).
    
    return 0;
}
</div><p id="dbdcea33_892">In this example:</p><ul class="list _ul" id="dbdcea33_893"><li class="list__item" id="dbdcea33_894"><p>The <code class="code" id="dbdcea33_895">FileHandler</code> class takes the filename in its constructor and opens the file. If the file cannot be opened, an error message is printed (you might choose to throw an exception in a more robust implementation).</p></li><li class="list__item" id="dbdcea33_896"><p>The destructor of <code class="code" id="dbdcea33_897">FileHandler</code> is responsible for closing the file. It automatically gets called when the <code class="code" id="dbdcea33_898">FileHandler</code> object goes out of scope.</p></li></ul><p id="dbdcea33_899">Now, when an instance of <code class="code" id="dbdcea33_900">FileHandler</code> is created in the <code class="code" id="dbdcea33_901">main</code> function, the file is opened, and when the object goes out of scope (at the end of the <code class="code" id="dbdcea33_902">main</code> function), the file is automatically closed. This ensures that the file is closed properly, even if an exception is thrown.</p><p id="dbdcea33_903">RAII is not limited to file handling; it can be applied to various resources such as memory, sockets, database connections, etc. It simplifies resource management and helps in writing more robust and error-resistant code.</p></section><section class="chapter"><h2 id="11-custom-memory-allocators" data-toc="11-custom-memory-allocators"   >11. Custom Memory Allocators</h2><p id="dbdcea33_904">Custom memory allocators in C++ allow you to define your own strategies for allocating and deallocating memory. This can be useful in scenarios where the default memory allocation mechanisms provided by the standard library (<code class="code" id="dbdcea33_905">new</code> and <code class="code" id="dbdcea33_906">delete</code> operators) may not be optimal for your specific use case. Custom memory allocators can be designed to improve performance, manage memory in a specialized way, or integrate with external memory management systems.</p><p id="dbdcea33_907">Here's a simple example of a custom memory allocator using the standard <code class="code" id="dbdcea33_908">malloc</code> and <code class="code" id="dbdcea33_909">free</code> functions. This allocator provides a basic implementation of a fixed-size memory pool:</p><div class="code-block" data-lang="cpp"         >
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;

class CustomAllocator {
public:
    // Constructor takes the size of the memory pool
    explicit CustomAllocator(std::size_t poolSize) {
        memoryPool_ = std::malloc(poolSize);
        nextFree_ = memoryPool_;
    }

    // Destructor releases the allocated memory
    ~CustomAllocator() {
        std::free(memoryPool_);
    }

    // Allocate memory of a specified size
    void* allocate(std::size_t size) {
        if (nextFree_ + size &lt;= memoryPool_ + poolSize_) {
            void* allocatedMemory = nextFree_;
            nextFree_ += size;
            return allocatedMemory;
        } else {
            // Custom handling for out-of-memory situations
            throw std::bad_alloc();
        }
    }

    // Deallocate memory
    void deallocate(void* ptr) {
        // For this simple example, we don't do anything special during deallocation
        // In a real-world scenario, you might want to implement more sophisticated logic
    }

private:
    std::size_t poolSize_;
    void* memoryPool_;
    void* nextFree_;
};

// Example usage
int main() {
    // Create a custom allocator with a pool size of 1024 bytes
    CustomAllocator allocator(1024);

    // Allocate memory using the custom allocator
    int* intPtr = static_cast&lt;int*&gt;(allocator.allocate(sizeof(int)));

    // Use the allocated memory
    *intPtr = 42;

    // Deallocate memory when it's no longer needed
    allocator.deallocate(intPtr);

    return 0;
}
</div><p id="dbdcea33_911">In this example, the <code class="code" id="dbdcea33_912">CustomAllocator</code> class is a basic implementation that uses a fixed-size memory pool. The <code class="code" id="dbdcea33_913">allocate</code> function is responsible for allocating memory, and the <code class="code" id="dbdcea33_914">deallocate</code> function is a placeholder for any necessary cleanup during deallocation.</p><p id="dbdcea33_915">It's important to note that real-world custom allocators can be significantly more complex, depending on the specific requirements of your application. They might involve strategies such as memory pooling, caching, or integration with external memory management systems. Additionally, C++ provides more advanced allocator customization points, like <code class="code" id="dbdcea33_916">std::allocator_traits</code> and <code class="code" id="dbdcea33_917">std::pmr::memory_resource</code>, which allow for greater flexibility and control over memory allocation in certain contexts.</p></section><section class="chapter"><h2 id="12-crtp-curiously-recurring-template-pattern" data-toc="12-crtp-curiously-recurring-template-pattern"   >12. CRTP (Curiously Recurring Template Pattern)</h2><p id="dbdcea33_918">The Curiously Recurring Template Pattern (CRTP) is a C++ programming technique where a class template is used as a base class for a derived class, and the derived class is instantiated with the derived type itself as a template argument. The main idea behind CRTP is to leverage static polymorphism through template specialization, allowing the derived class to inherit behavior from the base class.</p><p id="dbdcea33_919">Here's a simple example to illustrate CRTP:</p><div class="code-block" data-lang="cpp"         >
// Base template class using CRTP
template &lt;typename Derived&gt;
class Base {
public:
    void commonFunction() {
        // Implementation in the base class that uses functions from the derived class
        static_cast&lt;Derived*&gt;(this)-&gt;implementation();
    }

    // Other common functions or features can be defined here
};

// Derived class using CRTP
class DerivedClass : public Base&lt;DerivedClass&gt; {
public:
    void implementation() {
        // Implementation specific to the derived class
        // This function is called by commonFunction in the base class
        // Add your specific logic here
    }

    // Other functions or features specific to the derived class
};

int main() {
    DerivedClass obj;
    obj.commonFunction(); // Calls commonFunction in the base class, which in turn calls implementation in DerivedClass

    return 0;
}
</div><p id="dbdcea33_921">In this example:</p><ul class="list _ul" id="dbdcea33_922"><li class="list__item" id="dbdcea33_923"><p id="dbdcea33_924"><code class="code" id="dbdcea33_925">Base</code> is a template class that takes a type parameter <code class="code" id="dbdcea33_926">Derived</code>. It provides a common function <code class="code" id="dbdcea33_927">commonFunction()</code> that makes use of a function <code class="code" id="dbdcea33_928">implementation()</code> which is expected to be defined in the derived class.</p></li><li class="list__item" id="dbdcea33_929"><p id="dbdcea33_930"><code class="code" id="dbdcea33_931">DerivedClass</code> is derived from <code class="code" id="dbdcea33_932">Base&lt;DerivedClass&gt;</code>. It provides the specific implementation for the <code class="code" id="dbdcea33_933">implementation()</code> function.</p></li><li class="list__item" id="dbdcea33_934"><p id="dbdcea33_935">When <code class="code" id="dbdcea33_936">commonFunction()</code> is called on an object of type <code class="code" id="dbdcea33_937">DerivedClass</code>, it calls <code class="code" id="dbdcea33_938">implementation()</code> in <code class="code" id="dbdcea33_939">DerivedClass</code> due to the use of the CRTP.</p></li></ul><p id="dbdcea33_940">CRTP allows the base class to &quot;know&quot; about the derived class and call its functions statically at compile time. This pattern is particularly useful for implementing certain types of static polymorphism without the overhead of virtual functions and runtime dispatch.</p></section><section class="chapter"><h2 id="13-c-concepts-since-c-20" data-toc="13-c-concepts-since-c-20"   >13. C++ Concepts (since C++20)</h2><p id="dbdcea33_941">C++ Concepts were introduced in C++20 to improve template programming by allowing you to specify constraints on template parameters. Concepts provide a way to express the requirements on template arguments more clearly and provide better error messages when those requirements are not met.</p><p id="dbdcea33_942">Let's look at a simple example to illustrate the use of C++ Concepts. Suppose you want to create a template function that calculates the sum of elements in a container. You might want to ensure that the container passed to the function supports the <code class="code" id="dbdcea33_943">begin()</code> and <code class="code" id="dbdcea33_944">end()</code> member functions.</p><p id="dbdcea33_945">Here's how you could implement this using Concepts:</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

// Define a concept named Iterable
template &lt;typename T&gt;
concept Iterable = requires(T t) {
    { t.begin() } -&gt; typename T::iterator;
    { t.end() } -&gt; typename T::iterator;
};

// Template function that calculates the sum of elements in a container
template &lt;Iterable Container&gt;
auto calculateSum(const Container&amp; container) {
    typename Container::value_type sum = 0; // value_type is a type member of the container
    for (const auto&amp; element : container) {
        sum += element;
    }
    return sum;
}

int main() {
    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
    std::list&lt;double&gt; lst = {1.1, 2.2, 3.3, 4.4, 5.5};

    // Both std::vector and std::list satisfy the Iterable concept
    std::cout &lt;&lt; &quot;Sum of vector elements: &quot; &lt;&lt; calculateSum(vec) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Sum of list elements: &quot; &lt;&lt; calculateSum(lst) &lt;&lt; std::endl;

    // Uncommenting the line below would result in a compilation error
    // std::cout &lt;&lt; &quot;Sum of invalid container elements: &quot; &lt;&lt; calculateSum(42) &lt;&lt; std::endl;

    return 0;
}
</div><p id="dbdcea33_947">In this example:</p><ul class="list _ul" id="dbdcea33_948"><li class="list__item" id="dbdcea33_949"><p>The <code class="code" id="dbdcea33_950">Iterable</code> concept is defined using the <code class="code" id="dbdcea33_951">requires</code> clause, specifying that the container must have <code class="code" id="dbdcea33_952">begin()</code> and <code class="code" id="dbdcea33_953">end()</code> member functions returning iterators.</p></li><li class="list__item" id="dbdcea33_954"><p>The <code class="code" id="dbdcea33_955">calculateSum</code> function is templated on a type that satisfies the <code class="code" id="dbdcea33_956">Iterable</code> concept.</p></li><li class="list__item" id="dbdcea33_957"><p>The <code class="code" id="dbdcea33_958">main</code> function demonstrates using the <code class="code" id="dbdcea33_959">calculateSum</code> function with both a <code class="code" id="dbdcea33_960">std::vector</code> and a <code class="code" id="dbdcea33_961">std::list</code>.</p></li><li class="list__item" id="dbdcea33_962"><p>If you uncomment the line attempting to use <code class="code" id="dbdcea33_963">calculateSum</code> with an invalid container (e.g., an integer), the code won't compile, and you'll get a clear error message indicating that the template requirements are not satisfied.</p></li></ul><p id="dbdcea33_964">C++ Concepts help make template code more readable, maintainable, and provide better diagnostics when something goes wrong.</p></section><section class="chapter"><h2 id="14-user-defined-literals" data-toc="14-user-defined-literals"   >14. User-Defined Literals</h2><p id="dbdcea33_965">User-defined literals in C++ allow you to define custom suffixes for literal values. These suffixes are applied to numeric literals, string literals, or character literals. User-defined literals provide a way to create more readable and expressive code by extending the language with domain-specific notations.</p><p id="dbdcea33_966">Here's a basic explanation along with an example:</p><section class="chapter"><h3 id="syntax" data-toc="syntax"   >Syntax:</h3><div class="code-block" data-lang="cpp"         >
&lt;return_type&gt; operator &quot;&quot; _&lt;suffix&gt;(&lt;parameter&gt;);
</div><ul class="list _ul" id="dbdcea33_968"><li class="list__item" id="dbdcea33_969"><p><code class="code" id="dbdcea33_970">&lt;return_type&gt;</code> is the type of the user-defined literal.</p></li><li class="list__item" id="dbdcea33_971"><p><code class="code" id="dbdcea33_972">&lt;suffix&gt;</code> is the custom suffix you define.</p></li><li class="list__item" id="dbdcea33_973"><p><code class="code" id="dbdcea33_974">&lt;parameter&gt;</code> is the literal value to which the suffix is applied.</p></li></ul></section><section class="chapter"><h3 id="example" data-toc="example"   >Example:</h3><p id="dbdcea33_975">Let's create a simple user-defined literal for converting Celsius to Fahrenheit:</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

// User-defined literal for Celsius to Fahrenheit conversion
double operator &quot;&quot; _CelsiusToFahrenheit(long double celsius) {
    return static_cast&lt;double&gt;(celsius * 9.0 / 5.0 + 32.0);
}

int main() {
    // Using the user-defined literal
    double temperatureInFahrenheit = 25.0_CelsiusToFahrenheit;

    std::cout &lt;&lt; &quot;25 degrees Celsius is approximately &quot;
              &lt;&lt; temperatureInFahrenheit &lt;&lt; &quot; degrees Fahrenheit.&quot; &lt;&lt; std::endl;

    return 0;
}
</div><p id="dbdcea33_977">In this example:</p><ul class="list _ul" id="dbdcea33_978"><li class="list__item" id="dbdcea33_979"><p>The user-defined literal is <code class="code" id="dbdcea33_980">operator &quot;&quot; _CelsiusToFahrenheit</code>.</p></li><li class="list__item" id="dbdcea33_981"><p>The suffix is <code class="code" id="dbdcea33_982">_CelsiusToFahrenheit</code>.</p></li><li class="list__item" id="dbdcea33_983"><p>The parameter is <code class="code" id="dbdcea33_984">long double celsius</code>.</p></li></ul><p id="dbdcea33_985">Now, when you use the literal <code class="code" id="dbdcea33_986">25.0_CelsiusToFahrenheit</code>, it's translated into a call to the <code class="code" id="dbdcea33_987">operator &quot;&quot; _CelsiusToFahrenheit</code> function, and the temperature is converted from Celsius to Fahrenheit.</p><p id="dbdcea33_988">Note: The compiler recognizes user-defined literals based on their suffixes, and the actual implementation of the conversion is done inside the corresponding <code class="code" id="dbdcea33_989">operator &quot;&quot;</code> function. The suffix must start with an underscore (<code class="code" id="dbdcea33_990">_</code>) followed by a sequence of characters.</p></section></section><section class="chapter"><h2 id="15-expression-templates" data-toc="15-expression-templates"   >15. Expression Templates</h2><p id="dbdcea33_991">Expression templates are a C++ technique that enables the creation of efficient, temporary-free representations of mathematical expressions. This is often used in the context of numerical computations, where performance is critical. The idea is to delay the evaluation of expressions until the final result is actually needed, reducing the number of temporary objects created during the computation.</p><p id="dbdcea33_992">Let's consider a simple example of a vector expression template. We'll create a <code class="code" id="dbdcea33_993">Vector</code> class and define operations like addition using expression templates:</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

// Forward declaration of the Vector class
template &lt;typename T, size_t N&gt;
class Vector;

// Expression template for vector addition
template &lt;typename T, size_t N&gt;
class VectorAdditionExpression {
public:
    VectorAdditionExpression(const Vector&lt;T, N&gt;&amp; lhs, const Vector&lt;T, N&gt;&amp; rhs)
        : lhs(lhs), rhs(rhs) {}

    T operator[](size_t index) const {
        return lhs[index] + rhs[index];
    }

private:
    const Vector&lt;T, N&gt;&amp; lhs;
    const Vector&lt;T, N&gt;&amp; rhs;
};

// Vector class
template &lt;typename T, size_t N&gt;
class Vector {
public:
    // Constructor for initializing the vector
    Vector(std::initializer_list&lt;T&gt; values) {
        size_t i = 0;
        for (const auto&amp; value : values) {
            data[i++] = value;
        }
    }

    // Access element at the specified index
    T operator[](size_t index) const {
        return data[index];
    }

    // Create an expression template for vector addition
    VectorAdditionExpression&lt;T, N&gt; operator+(const Vector&amp; other) const {
        return VectorAdditionExpression&lt;T, N&gt;(*this, other);
    }

private:
    T data[N];
};

// Overload &lt;&lt; operator to print vectors
template &lt;typename T, size_t N&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector&lt;T, N&gt;&amp; vec) {
    os &lt;&lt; &quot;(&quot;;
    for (size_t i = 0; i &lt; N; ++i) {
        os &lt;&lt; vec[i];
        if (i &lt; N - 1) {
            os &lt;&lt; &quot;, &quot;;
        }
    }
    os &lt;&lt; &quot;)&quot;;
    return os;
}

int main() {
    // Create two vectors
    Vector&lt;int, 3&gt; v1 = {1, 2, 3};
    Vector&lt;int, 3&gt; v2 = {4, 5, 6};

    // Use expression templates to represent the addition
    VectorAdditionExpression&lt;int, 3&gt; resultExpression = v1 + v2;

    // Print the result without actually performing the addition
    std::cout &lt;&lt; &quot;Result without evaluation: &quot; &lt;&lt; resultExpression &lt;&lt; std::endl;

    // Evaluate the result and print
    Vector&lt;int, 3&gt; result = resultExpression;
    std::cout &lt;&lt; &quot;Result after evaluation: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
}
</div><p id="dbdcea33_995">In this example, when you perform the addition <code class="code" id="dbdcea33_996">v1 + v2</code>, it creates an expression template (<code class="code" id="dbdcea33_997">VectorAdditionExpression</code>) that represents the addition operation without actually performing it. The addition is only evaluated when needed, such as when the result is assigned to another vector (<code class="code" id="dbdcea33_998">Vector&lt;int, 3&gt; result = resultExpression;</code>). This technique can help avoid unnecessary temporary objects and improve performance in certain scenarios.</p></section><section class="chapter"><h2 id="16-aspect-oriented-programming-aop" data-toc="16-aspect-oriented-programming-aop"   >16. Aspect-Oriented Programming (AOP)</h2><p id="dbdcea33_999">Aspect-Oriented Programming (AOP) is a programming paradigm that allows you to modularize cross-cutting concerns in a software application. Cross-cutting concerns are aspects of a program that affect multiple modules and are often hard to modularize using traditional programming paradigms. AOP provides a way to separate these concerns from the main business logic, making the code more modular and maintainable.</p><p id="dbdcea33_1000">In AOP, an &quot;aspect&quot; is a module that encapsulates a cross-cutting concern. Aspects are defined separately from the main business logic and are then woven into the code at specific points (join points) during the compilation process.</p><p id="dbdcea33_1001">Let's illustrate AOP with a simple example:</p><p id="dbdcea33_1002">Consider a logging aspect that logs information before and after the execution of certain methods. We want to add logging without cluttering the business logic of our application.</p><div class="code-block" data-lang="cpp"         >
#include &lt;iostream&gt;

// Business Logic Class
class MathOperation {
public:
    int add(int a, int b) {
        return a + b;
    }

    int subtract(int a, int b) {
        return a - b;
    }
};

// Aspect for Logging
class LoggingAspect {
public:
    template &lt;typename Function, typename... Args&gt;
    static auto logWrapper(Function&amp;&amp; func, Args&amp;&amp;... args) {
        std::cout &lt;&lt; &quot;Entering function.&quot; &lt;&lt; std::endl;

        // Execute the original function
        auto result = std::forward&lt;Function&gt;(func)(std::forward&lt;Args&gt;(args)...);

        std::cout &lt;&lt; &quot;Exiting function.&quot; &lt;&lt; std::endl;

        return result;
    }
};

// A macro to apply the logging aspect
#define LOGGED_METHOD(Class, Method) \
    LoggingAspect::logWrapper(&amp;Class::Method, this, ##__VA_ARGS__)

int main() {
    MathOperation calculator;

    // Logging is applied to the 'add' method using the macro
    int result = LOGGED_METHOD(MathOperation, add)(3, 4);

    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
}
</div><p id="dbdcea33_1004">In this example:</p><ul class="list _ul" id="dbdcea33_1005"><li class="list__item" id="dbdcea33_1006"><p><code class="code" id="dbdcea33_1007">MathOperation</code> is the class representing the business logic.</p></li><li class="list__item" id="dbdcea33_1008"><p><code class="code" id="dbdcea33_1009">LoggingAspect</code> is the aspect that logs before and after the execution of a method.</p></li><li class="list__item" id="dbdcea33_1010"><p>The <code class="code" id="dbdcea33_1011">LOGGED_METHOD</code> macro is used to apply the logging aspect to a specific method. It takes the class name and method name as arguments.</p></li></ul><p id="dbdcea33_1012">The <code class="code" id="dbdcea33_1013">logWrapper</code> method in the <code class="code" id="dbdcea33_1014">LoggingAspect</code> is a template function that takes a callable (like a method) and its arguments. It logs before and after the execution of the callable and returns the result.</p><p id="dbdcea33_1015">Using the <code class="code" id="dbdcea33_1016">LOGGED_METHOD</code> macro, we apply the logging aspect to the <code class="code" id="dbdcea33_1017">add</code> method of the <code class="code" id="dbdcea33_1018">MathOperation</code> class. When the <code class="code" id="dbdcea33_1019">add</code> method is called, the logging aspect is automatically woven into the code, resulting in log messages being printed before and after the method execution.</p><p id="dbdcea33_1020">This is a simplified example, and in real-world scenarios, AOP frameworks provide more sophisticated ways to define and apply aspects. However, this example illustrates the basic concept of separating cross-cutting concerns from the main business logic using AOP.</p></section><div class="last-modified"> Last modified: 23 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="threads.html">Threads</a>   <a class="navigation-links__next" href="templates-and-template-metaprogramming.html">Templates and Template Metaprogramming</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>