<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-23T01:31:58.4877725"><meta name="build-number" content="${buildNumber}">       <title>Bitwise Operations | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-bitwise-and","level":0,"title":"2. Bitwise AND (\u0026)","anchor":"#2-bitwise-and"},{"id":"3-bitwise-or","level":0,"title":"3. Bitwise OR (|)","anchor":"#3-bitwise-or"},{"id":"4-bitwise-xor","level":0,"title":"4. Bitwise XOR (^)","anchor":"#4-bitwise-xor"},{"id":"5-bitwise-not","level":0,"title":"5. Bitwise NOT (~)","anchor":"#5-bitwise-not"},{"id":"6-left-shift","level":0,"title":"6. Left Shift (\u003c\u003c)","anchor":"#6-left-shift"},{"id":"7-right-shift","level":0,"title":"7. Right Shift (\u003e\u003e)","anchor":"#7-right-shift"},{"id":"8-real-world-applications","level":0,"title":"8. Real World Applications","anchor":"#8-real-world-applications"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Bitwise Operations | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="bitwise-operations.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Bitwise Operations | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "bitwise-operations.html#webpage", "url": "bitwise-operations.html", "name": "Bitwise Operations | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="Bitwise-Operations" data-main-title="Bitwise Operations" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="C-language.md|C language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Bitwise-Operations"   id="Bitwise-Operations.md">Bitwise Operations</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><p id="b98c9b10_696">Bitwise operations in C involve manipulating individual bits of integers at the binary level. These operations are useful for tasks like setting or clearing specific bits, toggling bits, or extracting information from binary representations. The bitwise operators in C include:</p><ol class="list _decimal" id="b98c9b10_697" type="1"><li class="list__item" id="b98c9b10_698"><p id="b98c9b10_699"><span class="control" id="b98c9b10_700">Bitwise AND (<code class="code" id="b98c9b10_701">&amp;</code>):</span></p><ul class="list _ul" id="b98c9b10_702"><li class="list__item" id="b98c9b10_703"><p>The <code class="code" id="b98c9b10_704">&amp;</code> operator performs a bitwise AND operation.</p></li><li class="list__item" id="b98c9b10_705"><p>It compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the resulting bit is set to 1; otherwise, it is set to 0.</p></li></ul><div class="code-block" data-lang="c"         >
int result = a &amp; b;
</div></li><li class="list__item" id="b98c9b10_707"><p id="b98c9b10_708"><span class="control" id="b98c9b10_709">Bitwise OR (<code class="code" id="b98c9b10_710">|</code>):</span></p><ul class="list _ul" id="b98c9b10_711"><li class="list__item" id="b98c9b10_712"><p>The <code class="code" id="b98c9b10_713">|</code> operator performs a bitwise OR operation.</p></li><li class="list__item" id="b98c9b10_714"><p>It compares each bit of the first operand to the corresponding bit of the second operand. If either bit is 1, the resulting bit is set to 1; otherwise, it is set to 0.</p></li></ul><div class="code-block" data-lang="c"         >
int result = a | b;
</div></li><li class="list__item" id="b98c9b10_716"><p id="b98c9b10_717"><span class="control" id="b98c9b10_718">Bitwise XOR (<code class="code" id="b98c9b10_719">^</code>):</span></p><ul class="list _ul" id="b98c9b10_720"><li class="list__item" id="b98c9b10_721"><p>The <code class="code" id="b98c9b10_722">^</code> operator performs a bitwise XOR (exclusive OR) operation.</p></li><li class="list__item" id="b98c9b10_723"><p>It compares each bit of the first operand to the corresponding bit of the second operand. If the bits are different, the resulting bit is set to 1; otherwise, it is set to 0.</p></li></ul><div class="code-block" data-lang="c"         >
int result = a ^ b;
</div></li><li class="list__item" id="b98c9b10_725"><p id="b98c9b10_726"><span class="control" id="b98c9b10_727">Bitwise NOT (<code class="code" id="b98c9b10_728">~</code>):</span></p><ul class="list _ul" id="b98c9b10_729"><li class="list__item" id="b98c9b10_730"><p>The <code class="code" id="b98c9b10_731">~</code> operator performs a bitwise NOT operation.</p></li><li class="list__item" id="b98c9b10_732"><p>It flips each bit of the operand, changing 1s to 0s and vice versa.</p></li></ul><div class="code-block" data-lang="c"         >
int result = ~a;
</div></li><li class="list__item" id="b98c9b10_734"><p id="b98c9b10_735"><span class="control" id="b98c9b10_736">Left Shift (<code class="code" id="b98c9b10_737">&lt;&lt;</code>):</span></p><ul class="list _ul" id="b98c9b10_738"><li class="list__item" id="b98c9b10_739"><p>The <code class="code" id="b98c9b10_740">&lt;&lt;</code> operator performs a left shift operation.</p></li><li class="list__item" id="b98c9b10_741"><p>It shifts the bits of the left operand to the left by the number of positions specified by the right operand.</p></li></ul><div class="code-block" data-lang="c"         >
int result = a &lt;&lt; 2;  // Left shift 'a' by 2 positions
</div></li><li class="list__item" id="b98c9b10_743"><p id="b98c9b10_744"><span class="control" id="b98c9b10_745">Right Shift (<code class="code" id="b98c9b10_746">&gt;&gt;</code>):</span></p><ul class="list _ul" id="b98c9b10_747"><li class="list__item" id="b98c9b10_748"><p>The <code class="code" id="b98c9b10_749">&gt;&gt;</code> operator performs a right shift operation.</p></li><li class="list__item" id="b98c9b10_750"><p>It shifts the bits of the left operand to the right by the number of positions specified by the right operand. The leftmost bits are filled based on the sign bit for signed integers or with zeros for unsigned integers.</p></li></ul><div class="code-block" data-lang="c"         >
int result = a &gt;&gt; 1;  // Right shift 'a' by 1 position
</div></li></ol><p id="b98c9b10_752">Bitwise operations are often used in low-level programming, such as embedded systems, device drivers, and graphics programming, where direct manipulation of bits is necessary. They can also be used for certain optimization techniques and algorithmic tasks.</p></section><section class="chapter"><h2 id="2-bitwise-and" data-toc="2-bitwise-and"   >2. Bitwise AND (&amp;)</h2><p id="b98c9b10_753">Bitwise AND (<code class="code" id="b98c9b10_754">&amp;</code>) is a binary operator in C that performs a bitwise AND operation on each pair of corresponding bits of two integers. The result of a bitwise AND operation is a new integer where each bit in the result is set to 1 only if the corresponding bits in both operands are 1. If any of the bits is 0 in either operand, the result bit will be 0.</p><p id="b98c9b10_755">Here's a simple example to illustrate the bitwise AND operation:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

int main() {
    // Example values
    unsigned int a = 0b11010110;  // Binary: 11010110
    unsigned int b = 0b10101101;  // Binary: 10101101

    // Bitwise AND operation
    unsigned int result = a &amp; b;

    // Displaying the results in binary and decimal
    printf(&quot;Binary representation of a: %08b\n&quot;, a);
    printf(&quot;Binary representation of b: %08b\n&quot;, b);
    printf(&quot;Result of (a &amp; b): %08b\n&quot;, result);
    printf(&quot;Decimal result of (a &amp; b): %u\n&quot;, result);

    return 0;
}
</div><p id="b98c9b10_757">Output:</p><div class="code-block" data-lang="none"         >
Binary representation of a: 11010110
Binary representation of b: 10101101
Result of (a &amp; b): 10000100
Decimal result of (a &amp; b): 132
</div><p id="b98c9b10_759">In this example:</p><ul class="list _ul" id="b98c9b10_760"><li class="list__item" id="b98c9b10_761"><p><code class="code" id="b98c9b10_762">a</code> has the binary representation <code class="code" id="b98c9b10_763">11010110</code>.</p></li><li class="list__item" id="b98c9b10_764"><p><code class="code" id="b98c9b10_765">b</code> has the binary representation <code class="code" id="b98c9b10_766">10101101</code>.</p></li><li class="list__item" id="b98c9b10_767"><p>The bitwise AND operation <code class="code" id="b98c9b10_768">a &amp; b</code> results in the binary <code class="code" id="b98c9b10_769">10000100</code>, which is equivalent to decimal <code class="code" id="b98c9b10_770">132</code>.</p></li></ul><p id="b98c9b10_771">The bitwise AND operation helps in extracting or preserving specific bits in an integer. For example, if you want to check if a particular bit is set in an integer, you can use a bitwise AND with a bitmask that has only that bit set.</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

int main() {
    // Example values
    unsigned int num = 0b11010110;  // Binary: 11010110
    unsigned int bitmask = 0b00001000;  // Binary: 00001000

    // Check if a specific bit is set
    if ((num &amp; bitmask) != 0) {
        printf(&quot;The specified bit is set.\n&quot;);
    } else {
        printf(&quot;The specified bit is not set.\n&quot;);
    }

    return 0;
}
</div><p id="b98c9b10_773">Output:</p><div class="code-block" data-lang="none"         >
The specified bit is set.
</div><p id="b98c9b10_775">In this example, the bitwise AND operation is used to check if a specific bit (the 4th bit from the right) is set in the variable <code class="code" id="b98c9b10_776">num</code>. If the result is not equal to zero, it means the specified bit is set.</p></section><section class="chapter"><h2 id="3-bitwise-or" data-toc="3-bitwise-or"   >3. Bitwise OR (|)</h2><p id="b98c9b10_777">Certainly! The bitwise OR (<code class="code" id="b98c9b10_778">|</code>) operator in C performs a bitwise OR operation on each pair of corresponding bits of two integers. The result has a 1 in each bit position where at least one of the corresponding bits in the operands is 1. Otherwise, the result has a 0 in that bit position.</p><p id="b98c9b10_779">Here's an example to illustrate bitwise OR in C:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

int main() {
    // Example values
    unsigned int a = 12;   // Binary: 1100
    unsigned int b = 25;   // Binary: 11001

    // Bitwise OR operation
    unsigned int result = a | b;

    // Displaying the results
    printf(&quot;a: %u (Binary: %08b)\n&quot;, a, a);
    printf(&quot;b: %u (Binary: %08b)\n&quot;, b, b);
    printf(&quot;Result of a | b: %u (Binary: %08b)\n&quot;, result, result);

    return 0;
}
</div><p id="b98c9b10_781">In this example, <code class="code" id="b98c9b10_782">a</code> is 12, which in binary is <code class="code" id="b98c9b10_783">1100</code>, and <code class="code" id="b98c9b10_784">b</code> is 25, which in binary is <code class="code" id="b98c9b10_785">11001</code>. The bitwise OR operation is then performed on these two values, and the result is stored in the variable <code class="code" id="b98c9b10_786">result</code>.</p><p id="b98c9b10_787">Here's the breakdown of the bitwise OR operation:</p><div class="code-block" data-lang="none"         >
    1100   (a)
  | 11001   (b)
  ----------
   11101   (Result)
</div><p id="b98c9b10_789">So, the decimal value of <code class="code" id="b98c9b10_790">result</code> is 29, and in binary, it is <code class="code" id="b98c9b10_791">11101</code>. Each bit in the result is determined by applying the bitwise OR operation to the corresponding bits of <code class="code" id="b98c9b10_792">a</code> and <code class="code" id="b98c9b10_793">b</code>. In this case, if at least one of the bits is 1, the result has a 1 in that position.</p></section><section class="chapter"><h2 id="4-bitwise-xor" data-toc="4-bitwise-xor"   >4. Bitwise XOR (^)</h2><p id="b98c9b10_794">Bitwise XOR (<code class="code" id="b98c9b10_795">^</code>) is a binary operation that performs an exclusive OR on each pair of corresponding bits. The result is 1 if the bits are different and 0 if the bits are the same. Here's a brief explanation with an example:</p><p id="b98c9b10_796">Consider two binary numbers, <code class="code" id="b98c9b10_797">a</code> and <code class="code" id="b98c9b10_798">b</code>:</p><div class="code-block" data-lang="none"         >
a = 1101
b = 1010
</div><p id="b98c9b10_800">Now, let's perform bitwise XOR (<code class="code" id="b98c9b10_801">^</code>) on each pair of corresponding bits:</p><div class="code-block" data-lang="none"         >
a   1 1 0 1
b   1 0 1 0
------------
result 0 1 1 1
</div><p id="b98c9b10_803">In this example, you can see that for each pair of corresponding bits:</p><ul class="list _ul" id="b98c9b10_804"><li class="list__item" id="b98c9b10_805"><p><code class="code" id="b98c9b10_806">1 XOR 1</code> results in <code class="code" id="b98c9b10_807">0</code> (because the bits are the same).</p></li><li class="list__item" id="b98c9b10_808"><p><code class="code" id="b98c9b10_809">1 XOR 0</code> results in <code class="code" id="b98c9b10_810">1</code> (because the bits are different).</p></li><li class="list__item" id="b98c9b10_811"><p><code class="code" id="b98c9b10_812">0 XOR 1</code> results in <code class="code" id="b98c9b10_813">1</code> (because the bits are different).</p></li><li class="list__item" id="b98c9b10_814"><p><code class="code" id="b98c9b10_815">1 XOR 0</code> results in <code class="code" id="b98c9b10_816">1</code> (because the bits are different).</p></li></ul><p id="b98c9b10_817">So, the final result of <code class="code" id="b98c9b10_818">a ^ b</code> is <code class="code" id="b98c9b10_819">0111</code> in binary, which is equivalent to <code class="code" id="b98c9b10_820">7</code> in decimal.</p><p id="b98c9b10_821">In C, you can use the bitwise XOR operator as follows:</p><div class="code-block" data-lang="c"         >
int a = 13;  // Binary: 1101
int b = 10;  // Binary: 1010
int result = a ^ b;  // Binary: 0111 (Decimal: 7)
</div><p id="b98c9b10_823">After this operation, the variable <code class="code" id="b98c9b10_824">result</code> will contain the bitwise XOR of <code class="code" id="b98c9b10_825">a</code> and <code class="code" id="b98c9b10_826">b</code>.</p></section><section class="chapter"><h2 id="5-bitwise-not" data-toc="5-bitwise-not"   >5. Bitwise NOT (~)</h2><p id="b98c9b10_827">The bitwise NOT (<code class="code" id="b98c9b10_828">~</code>) operator in C performs the operation of flipping each bit of the operand. If a bit is 0, it becomes 1, and if a bit is 1, it becomes 0. The NOT operation essentially inverts the bits of the operand.</p><p id="b98c9b10_829">Here's an example to illustrate the bitwise NOT operation:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

int main() {
    unsigned int a = 42;  // Binary representation: 00101010

    // Applying bitwise NOT to 'a'
    unsigned int result = ~a;

    printf(&quot;Original value of 'a': %u\n&quot;, a);
    printf(&quot;Bitwise NOT of 'a': %u\n&quot;, result);

    return 0;
}
</div><p id="b98c9b10_831">In this example, the variable <code class="code" id="b98c9b10_832">a</code> is initialized with the value 42, which has the binary representation <code class="code" id="b98c9b10_833">00101010</code>. When the bitwise NOT operation is applied to <code class="code" id="b98c9b10_834">a</code> using <code class="code" id="b98c9b10_835">~a</code>, each bit is inverted. Therefore, the result will have the binary representation <code class="code" id="b98c9b10_836">11010101</code>, which is the decimal value 213.</p><p id="b98c9b10_837">Output:</p><div class="code-block" data-lang="none"         >
Original value of 'a': 42
Bitwise NOT of 'a': 4294967253
</div><p id="b98c9b10_839">Keep in mind that the result of the bitwise NOT operation is an unsigned integer, and the output is displayed in decimal form. The actual representation of the bits in memory may depend on the size of the integer type (<code class="code" id="b98c9b10_840">int</code>, <code class="code" id="b98c9b10_841">unsigned int</code>, etc.) on your system. The example above assumes a typical 32-bit unsigned integer.</p></section><section class="chapter"><h2 id="6-left-shift" data-toc="6-left-shift"   >6. Left Shift (&lt;&lt;)</h2><p id="b98c9b10_842">The left shift (<code class="code" id="b98c9b10_843">&lt;&lt;</code>) operator in C is used to shift the bits of a binary representation of a number to the left by a specified number of positions. The syntax for the left shift operation is as follows:</p><div class="code-block" data-lang="c"         >
result = operand &lt;&lt; shift_amount;
</div><p id="b98c9b10_845">Here, <code class="code" id="b98c9b10_846">operand</code> is the number whose bits are to be shifted, and <code class="code" id="b98c9b10_847">shift_amount</code> is the number of positions to shift the bits to the left. The vacant bit positions on the right are filled with zeros.</p><p id="b98c9b10_848">Let's take an example to illustrate the left shift operation:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

int main() {
    // Example: Left shifting 5 (binary: 00000101) by 2 positions
    int original = 5;  // binary: 00000101
    int result = original &lt;&lt; 2;  // Left shift by 2 positions

    // Display the results
    printf(&quot;Original: %d\n&quot;, original);
    printf(&quot;Result: %d\n&quot;, result);

    return 0;
}
</div><p id="b98c9b10_850">In this example, we are left shifting the binary representation of the number <code class="code" id="b98c9b10_851">5</code> by <code class="code" id="b98c9b10_852">2</code> positions. The binary representation of <code class="code" id="b98c9b10_853">5</code> is <code class="code" id="b98c9b10_854">00000101</code>. The left shift by <code class="code" id="b98c9b10_855">2</code> positions results in the binary <code class="code" id="b98c9b10_856">00010100</code>, which is equivalent to decimal <code class="code" id="b98c9b10_857">20</code>.</p><p id="b98c9b10_858">Output:</p><div class="code-block" data-lang="none"         >
Original: 5
Result: 20
</div><p id="b98c9b10_860">Explanation:</p><ul class="list _ul" id="b98c9b10_861"><li class="list__item" id="b98c9b10_862"><p>Original binary representation of <code class="code" id="b98c9b10_863">5</code>: <code class="code" id="b98c9b10_864">00000101</code></p></li><li class="list__item" id="b98c9b10_865"><p>Left shift by <code class="code" id="b98c9b10_866">2</code> positions: <code class="code" id="b98c9b10_867">00000101 &lt;&lt; 2</code> becomes <code class="code" id="b98c9b10_868">00010100</code></p></li><li class="list__item" id="b98c9b10_869"><p>Decimal representation of the result: <code class="code" id="b98c9b10_870">00010100</code> is <code class="code" id="b98c9b10_871">20</code></p></li></ul><p id="b98c9b10_872">In general, left shifting a binary number by <code class="code" id="b98c9b10_873">n</code> positions is equivalent to multiplying the decimal value by <code class="code" id="b98c9b10_874">2^n</code>. In the example, left shifting <code class="code" id="b98c9b10_875">5</code> by <code class="code" id="b98c9b10_876">2</code> positions is equivalent to <code class="code" id="b98c9b10_877">5 * 2^2 = 20</code>.</p></section><section class="chapter"><h2 id="7-right-shift" data-toc="7-right-shift"   >7. Right Shift (&gt;&gt;)</h2><p id="b98c9b10_878">The right shift (<code class="code" id="b98c9b10_879">&gt;&gt;</code>) operator in C is used to shift the bits of a binary number to the right by a specified number of positions. It is a bitwise operator that is often used to perform division by powers of 2 or to extract specific bits from an integer. The syntax for the right shift operator is:</p><div class="code-block" data-lang="c"         >
result = operand &gt;&gt; shift_amount;
</div><p id="b98c9b10_881">Here, <code class="code" id="b98c9b10_882">operand</code> is the number whose bits are to be shifted, and <code class="code" id="b98c9b10_883">shift_amount</code> is the number of positions by which the bits are to be shifted to the right.</p><p id="b98c9b10_884">Let's look at an example:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

int main() {
    int num = 16;  // Binary representation: 00000000 00000000 00000000 00010000

    // Right shift 'num' by 2 positions
    int result = num &gt;&gt; 2;

    // Display the results
    printf(&quot;Original number: %d\n&quot;, num);
    printf(&quot;Result after right shift by 2 positions: %d\n&quot;, result);

    return 0;
}
</div><p id="b98c9b10_886">In this example, we start with the integer <code class="code" id="b98c9b10_887">num</code> having a binary representation of <code class="code" id="b98c9b10_888">00000000 00000000 00000000 00010000</code>. When we perform a right shift by 2 positions (<code class="code" id="b98c9b10_889">num &gt;&gt; 2</code>), the result will be <code class="code" id="b98c9b10_890">00000000 00000000 00000000 00000001</code> in binary, which is equivalent to the decimal number 1.</p><p id="b98c9b10_891">Explanation of the steps:</p><ol class="list _decimal" id="b98c9b10_892" type="1"><li class="list__item" id="b98c9b10_893"><p>Original number (<code class="code" id="b98c9b10_894">num</code>): <code class="code" id="b98c9b10_895">00000000 00000000 00000000 00010000</code></p></li><li class="list__item" id="b98c9b10_896"><p>Right shift by 2 positions: <code class="code" id="b98c9b10_897">00000000 00000000 00000000 00000001</code> (binary)</p></li><li class="list__item" id="b98c9b10_898"><p>Result: 1 (decimal)</p></li></ol><p id="b98c9b10_899">The right shift effectively divides the original number by 2 raised to the power of the shift amount. In this case, <code class="code" id="b98c9b10_900">16 &gt;&gt; 2</code> is equivalent to <code class="code" id="b98c9b10_901">16 / 2^2</code>, which is <code class="code" id="b98c9b10_902">16 / 4</code>, resulting in the value 4.</p><p id="b98c9b10_903">Keep in mind that for signed integers, the right shift may fill the vacant positions with the sign bit (arithmetic right shift), so the result depends on whether the original number is positive or negative.</p></section><section class="chapter"><h2 id="8-real-world-applications" data-toc="8-real-world-applications"   >8. Real World Applications</h2><p id="b98c9b10_904">One real-world application of bitwise operators is in the field of embedded systems, where resources are often limited, and memory efficiency is crucial. Let's consider an example of using bitwise operators in a program that deals with configuration flags or settings in a hypothetical embedded system.</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Define configuration flags using bitwise constants
#define FLAG1 (1 &lt;&lt; 0)  // Bit 0 corresponds to FLAG1
#define FLAG2 (1 &lt;&lt; 1)  // Bit 1 corresponds to FLAG2
#define FLAG3 (1 &lt;&lt; 2)  // Bit 2 corresponds to FLAG3
#define FLAG4 (1 &lt;&lt; 3)  // Bit 3 corresponds to FLAG4

// Function to set a flag in the configuration
void setFlag(unsigned int* config, unsigned int flag) {
    *config |= flag;  // Set the specified flag
}

// Function to clear a flag in the configuration
void clearFlag(unsigned int* config, unsigned int flag) {
    *config &amp;= ~flag;  // Clear the specified flag
}

// Function to check if a flag is set in the configuration
int isFlagSet(unsigned int config, unsigned int flag) {
    return (config &amp; flag) != 0;  // Check if the specified flag is set
}

int main() {
    unsigned int configuration = 0;  // Initialize configuration to all flags cleared

    // Set FLAG1 and FLAG3
    setFlag(&amp;configuration, FLAG1);
    setFlag(&amp;configuration, FLAG3);

    // Display the initial configuration
    printf(&quot;Initial Configuration: %u\n&quot;, configuration);

    // Check if FLAG2 is set
    if (isFlagSet(configuration, FLAG2)) {
        printf(&quot;FLAG2 is set.\n&quot;);
    } else {
        printf(&quot;FLAG2 is not set.\n&quot;);
    }

    // Clear FLAG1
    clearFlag(&amp;configuration, FLAG1);

    // Display the updated configuration
    printf(&quot;Updated Configuration: %u\n&quot;, configuration);

    return 0;
}
</div><p id="b98c9b10_906">In this example, we define configuration flags using bitwise constants (powers of 2) to represent different options or settings in an embedded system. The program provides functions (<code class="code" id="b98c9b10_907">setFlag</code>, <code class="code" id="b98c9b10_908">clearFlag</code>, <code class="code" id="b98c9b10_909">isFlagSet</code>) that use bitwise operators to manipulate and check the state of these flags within a configuration variable.</p><p id="b98c9b10_910">This kind of approach is memory-efficient, as it allows multiple configuration options to be stored in a single variable using bits. Each bit corresponds to a specific configuration setting, and bitwise operators help in setting, clearing, and checking these individual flags within the configuration. This is a common pattern in embedded systems where memory and resources are constrained.</p></section><div class="last-modified"> Last modified: 22 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="c-language.html">C language</a>   <a class="navigation-links__next" href="error-handling.html">Error handling</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>