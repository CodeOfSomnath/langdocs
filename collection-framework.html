<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-27T17:15:23.2586565"><meta name="build-number" content="${buildNumber}">       <title>Java Collection Framework | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-understanding-arraylist-in-java","level":0,"title":"2. Understanding ArrayList in Java","anchor":"#2-understanding-arraylist-in-java"},{"id":"3-understanding-linkedlist-in-java","level":0,"title":"3. Understanding LinkedList in Java","anchor":"#3-understanding-linkedlist-in-java"},{"id":"4-understanding-the-java-list-interface","level":0,"title":"4. Understanding the Java List Interface","anchor":"#4-understanding-the-java-list-interface"},{"id":"5-understanding-vectors-in-java","level":0,"title":"5. Understanding Vectors in Java","anchor":"#5-understanding-vectors-in-java"},{"id":"6-understanding-the-java-stack","level":0,"title":"6. Understanding the Java Stack","anchor":"#6-understanding-the-java-stack"},{"id":"7-understanding-collections-in-java","level":0,"title":"7. Understanding Collections in Java","anchor":"#7-understanding-collections-in-java"},{"id":"8-understanding-java-s-deque-interface","level":0,"title":"8. Understanding Java\u0027s Deque Interface","anchor":"#8-understanding-java-s-deque-interface"},{"id":"9-understanding-the-java-map-interface","level":0,"title":"9. Understanding the Java Map Interface","anchor":"#9-understanding-the-java-map-interface"},{"id":"10-understanding-hashmap-in-java","level":0,"title":"10. Understanding HashMap in Java","anchor":"#10-understanding-hashmap-in-java"},{"id":"11-understanding-hashset-in-java","level":0,"title":"11. Understanding HashSet in Java","anchor":"#11-understanding-hashset-in-java"},{"id":"12-understanding-sets-in-java","level":0,"title":"12. Understanding Sets in Java","anchor":"#12-understanding-sets-in-java"},{"id":"13-understanding-java-s-queue-interface","level":0,"title":"13. Understanding Java\u0027s Queue Interface","anchor":"#13-understanding-java-s-queue-interface"},{"id":"14-java-dictionary-k-v","level":0,"title":"14. Java Dictionary\u003cK, V\u003e","anchor":"#14-java-dictionary-k-v"},{"id":"15-understanding-hashtable-in-java","level":0,"title":"15. Understanding Hashtable in Java","anchor":"#15-understanding-hashtable-in-java"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Java Collection Framework | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="collection-framework.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Java Collection Framework | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "collection-framework.html#webpage", "url": "collection-framework.html", "name": "Java Collection Framework | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="Collection-Framework" data-main-title="Java Collection Framework" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Java-Language.md|Java Language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Collection-Framework"   id="Collection-Framework.md">Java Collection Framework</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><p id="b7332e06_3">The Java Collection Framework provides a comprehensive architecture for representing and manipulating collections of objects. It includes interfaces, implementations, and algorithms for managing data structures such as lists, sets, queues, and maps. Here's a brief overview of some key components:</p><ol class="list _decimal" id="b7332e06_4" type="1"><li class="list__item" id="b7332e06_5"><p id="b7332e06_6"><span class="control" id="b7332e06_7">Interfaces:</span></p><ul class="list _ul" id="b7332e06_8"><li class="list__item" id="b7332e06_9"><p><span class="control" id="b7332e06_10">List:</span> Ordered collection (e.g., ArrayList, LinkedList).</p></li><li class="list__item" id="b7332e06_11"><p><span class="control" id="b7332e06_12">Set:</span> Unordered collection with no duplicate elements (e.g., HashSet, TreeSet).</p></li><li class="list__item" id="b7332e06_13"><p><span class="control" id="b7332e06_14">Queue:</span> Ordered collection for holding elements to be processed (e.g., LinkedList, PriorityQueue).</p></li><li class="list__item" id="b7332e06_15"><p><span class="control" id="b7332e06_16">Map:</span> Key-value pairs (e.g., HashMap, TreeMap).</p></li></ul></li><li class="list__item" id="b7332e06_17"><p id="b7332e06_18"><span class="control" id="b7332e06_19">Classes (Implementations):</span></p><ul class="list _ul" id="b7332e06_20"><li class="list__item" id="b7332e06_21"><p><span class="control" id="b7332e06_22">ArrayList:</span> Dynamic array implementation of List.</p></li><li class="list__item" id="b7332e06_23"><p><span class="control" id="b7332e06_24">LinkedList:</span> Doubly linked list implementation of List.</p></li><li class="list__item" id="b7332e06_25"><p><span class="control" id="b7332e06_26">HashSet:</span> Unordered, non-duplicate elements implementation of Set.</p></li><li class="list__item" id="b7332e06_27"><p><span class="control" id="b7332e06_28">TreeSet:</span> Sorted set implemented using a tree.</p></li><li class="list__item" id="b7332e06_29"><p><span class="control" id="b7332e06_30">HashMap:</span> Unordered, key-value pairs implementation of Map.</p></li><li class="list__item" id="b7332e06_31"><p><span class="control" id="b7332e06_32">TreeMap:</span> Sorted map implemented using a tree.</p></li></ul></li><li class="list__item" id="b7332e06_33"><p id="b7332e06_34"><span class="control" id="b7332e06_35">Example Usage:</span></p><div class="code-block" data-lang="java"         >
// Creating a List
List&lt;String&gt; names = new ArrayList&lt;&gt;();
names.add(&quot;Alice&quot;);
names.add(&quot;Bob&quot;);
names.add(&quot;Charlie&quot;);

// Creating a Set
Set&lt;Integer&gt; numbers = new HashSet&lt;&gt;();
numbers.add(1);
numbers.add(2);
numbers.add(3);

// Creating a Map
Map&lt;String, Integer&gt; ageMap = new HashMap&lt;&gt;();
ageMap.put(&quot;Alice&quot;, 25);
ageMap.put(&quot;Bob&quot;, 30);
ageMap.put(&quot;Charlie&quot;, 22);

// Iterating through a List
for (String name : names) {
    System.out.println(name);
}

// Iterating through a Set
for (Integer number : numbers) {
    System.out.println(number);
}

// Iterating through a Map
for (Map.Entry&lt;String, Integer&gt; entry : ageMap.entrySet()) {
    System.out.println(entry.getKey() + &quot; - &quot; + entry.getValue());
}
</div><p id="b7332e06_37">This code snippet demonstrates the creation and usage of a List, Set, and Map in Java.</p></li></ol><p id="b7332e06_38">The Java Collection Framework simplifies data manipulation and fosters code reusability by providing a unified architecture for handling collections of various types.</p><figure  id="b7332e06_39"><img alt="Java Collection image" src="images/Collection_Hirearchy.png" title="Java Collection image"  width="706" height="706"></figure></section><section class="chapter"><h2 id="2-understanding-arraylist-in-java" data-toc="2-understanding-arraylist-in-java"   >2. Understanding ArrayList in Java</h2><p id="b7332e06_40"><span class="control" id="b7332e06_41">Introduction:</span> In Java, the <code class="code" id="b7332e06_42">ArrayList</code> class is a part of the <code class="code" id="b7332e06_43">java.util</code> package and is a dynamic array implementation. It provides a resizable array, allowing the addition and removal of elements at runtime. Unlike regular arrays, <code class="code" id="b7332e06_44">ArrayList</code> can grow or shrink as needed, making it a versatile data structure in Java.</p><p id="b7332e06_45"><span class="control" id="b7332e06_46">Key Features of ArrayList:</span></p><ol class="list _decimal" id="b7332e06_47" type="1"><li class="list__item" id="b7332e06_48"><p><span class="control" id="b7332e06_49">Dynamic Sizing:</span> Automatically adjusts its size based on the number of elements.</p></li><li class="list__item" id="b7332e06_50"><p><span class="control" id="b7332e06_51">Random Access:</span> Provides constant-time access to any element using its index.</p></li><li class="list__item" id="b7332e06_52"><p><span class="control" id="b7332e06_53">Generic Type:</span> Supports storing elements of any data type through the use of generics.</p></li></ol><p id="b7332e06_54"><span class="control" id="b7332e06_55">Syntax:</span></p><div class="code-block" data-lang="java"         >
import java.util.ArrayList;

// Declaration
ArrayList&lt;DataType&gt; list = new ArrayList&lt;&gt;();

// Initialization
list.add(element);
</div><p id="b7332e06_57"><span class="control" id="b7332e06_58">Example: Using ArrayList in Java:</span></p><div class="code-block" data-lang="java"         >
import java.util.ArrayList;

public class ArrayListExample {
    public static void main(String[] args) {
        // Creating an ArrayList of Strings
        ArrayList&lt;String&gt; fruits = new ArrayList&lt;&gt;();

        // Adding elements
        fruits.add(&quot;Apple&quot;);
        fruits.add(&quot;Banana&quot;);
        fruits.add(&quot;Orange&quot;);

        // Accessing elements
        System.out.println(&quot;Fruits: &quot; + fruits);

        // Getting the size of the ArrayList
        int size = fruits.size();
        System.out.println(&quot;Number of fruits: &quot; + size);

        // Removing an element
        fruits.remove(&quot;Banana&quot;);
        System.out.println(&quot;Fruits after removing Banana: &quot; + fruits);

        // Checking if an element exists
        boolean containsApple = fruits.contains(&quot;Apple&quot;);
        System.out.println(&quot;Does it contain Apple? &quot; + containsApple);
    }
}
</div><p id="b7332e06_60"><span class="control" id="b7332e06_61">Output:</span></p><div class="code-block" data-lang="none"         >
Fruits: [Apple, Banana, Orange]
Number of fruits: 3
Fruits after removing Banana: [Apple, Orange]
Does it contain Apple? true
</div><p id="b7332e06_63">In this example, we create an <code class="code" id="b7332e06_64">ArrayList</code> to store strings representing fruit names. We perform common operations such as adding, accessing, removing, and checking for the existence of elements.</p><p id="b7332e06_65"><span class="control" id="b7332e06_66">Conclusion:</span> Understanding the <code class="code" id="b7332e06_67">ArrayList</code> class in Java is essential for working with dynamic collections of data. Its flexibility and ease of use make it a popular choice for developers when dealing with variable-sized datasets.</p></section><section class="chapter"><h2 id="3-understanding-linkedlist-in-java" data-toc="3-understanding-linkedlist-in-java"   >3. Understanding LinkedList in Java</h2><p id="b7332e06_68">A linked list is a data structure in Java that consists of a sequence of elements, where each element points to the next element in the sequence. Unlike arrays, linked lists do not have a fixed size, and elements can be easily inserted or removed. The basic building block of a linked list is a node, which contains both data and a reference (or link) to the next node in the sequence.</p><p id="b7332e06_69">Here's a simple example of implementing a LinkedList in Java:</p><div class="code-block" data-lang="java"         >
class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;

    public LinkedList() {
        this.head = null;
    }

    // Method to insert a new node at the end of the linked list
    public void append(int data) {
        Node newNode = new Node(data);

        if (head == null) {
            head = newNode;
            return;
        }

        Node last = head;
        while (last.next != null) {
            last = last.next;
        }

        last.next = newNode;
    }

    // Method to display the linked list
    public void display() {
        Node current = head;

        while (current != null) {
            System.out.print(current.data + &quot; &quot;);
            current = current.next;
        }

        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        // Appending elements to the linked list
        linkedList.append(1);
        linkedList.append(2);
        linkedList.append(3);

        // Displaying the linked list
        System.out.println(&quot;Linked List elements:&quot;);
        linkedList.display();
    }
}
</div><p id="b7332e06_71">In this example, the <code class="code" id="b7332e06_72">LinkedList</code> class has a <code class="code" id="b7332e06_73">head</code> attribute, which points to the first node in the list. The <code class="code" id="b7332e06_74">Node</code> class represents each element in the list. The <code class="code" id="b7332e06_75">append</code> method is used to add a new node to the end of the list, and the <code class="code" id="b7332e06_76">display</code> method is used to print the elements of the linked list.</p><p id="b7332e06_77">This is a basic implementation, and there are more advanced features that can be added, such as inserting at a specific position, deleting nodes, and more. Linked lists are fundamental in understanding data structures and are widely used in various applications.</p></section><section class="chapter"><h2 id="4-understanding-the-java-list-interface" data-toc="4-understanding-the-java-list-interface"   >4. Understanding the Java List Interface</h2><p id="b7332e06_78">In Java, the <code class="code" id="b7332e06_79">List</code> interface is a part of the Java Collections Framework and extends the <code class="code" id="b7332e06_80">Collection</code> interface. It represents an ordered collection of elements, where each element can be accessed by its index. The <code class="code" id="b7332e06_81">List</code> interface provides methods for adding, removing, and accessing elements based on their position in the list.</p><section class="chapter"><h3 id="example-usage" data-toc="example-usage"   >Example Usage:</h3><div class="code-block" data-lang="java"         >
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Creating a list using ArrayList
        List&lt;String&gt; fruits = new ArrayList&lt;&gt;();

        // Adding elements to the list
        fruits.add(&quot;Apple&quot;);
        fruits.add(&quot;Banana&quot;);
        fruits.add(&quot;Orange&quot;);

        // Accessing elements by index
        System.out.println(&quot;First fruit: &quot; + fruits.get(0));
        System.out.println(&quot;Second fruit: &quot; + fruits.get(1));

        // Iterating through the list
        System.out.println(&quot;List of fruits:&quot;);
        for (String fruit : fruits) {
            System.out.println(fruit);
        }

        // Checking if the list contains a specific element
        boolean containsBanana = fruits.contains(&quot;Banana&quot;);
        System.out.println(&quot;Contains Banana: &quot; + containsBanana);

        // Removing an element by index
        fruits.remove(1);
        System.out.println(&quot;List after removing the second fruit:&quot;);
        for (String fruit : fruits) {
            System.out.println(fruit);
        }

        // Getting the size of the list
        int size = fruits.size();
        System.out.println(&quot;Size of the list: &quot; + size);
    }
}
</div><p id="b7332e06_83">In this example, we create a <code class="code" id="b7332e06_84">List</code> of strings using the <code class="code" id="b7332e06_85">ArrayList</code> implementation. We demonstrate adding elements, accessing elements by index, iterating through the list, checking for the presence of an element, removing an element by index, and getting the size of the list. The <code class="code" id="b7332e06_86">List</code> interface provides a flexible and powerful way to work with ordered collections in Java.</p></section></section><section class="chapter"><h2 id="5-understanding-vectors-in-java" data-toc="5-understanding-vectors-in-java"   >5. Understanding Vectors in Java</h2><p id="b7332e06_87">In Java, a <code class="code" id="b7332e06_88">Vector</code> is a dynamic, synchronized collection class provided by the Java Collections Framework. It extends the AbstractList class and implements the List interface, making it a versatile choice for handling dynamic arrays.</p><section class="chapter"><h3 id="example" data-toc="example"   >Example:</h3><div class="code-block" data-lang="java"         >
import java.util.Vector;
import java.util.Iterator;

public class VectorExample {
    public static void main(String[] args) {
        // Creating a Vector
        Vector&lt;String&gt; fruits = new Vector&lt;&gt;();

        // Adding elements
        fruits.add(&quot;Apple&quot;);
        fruits.add(&quot;Banana&quot;);
        fruits.add(&quot;Orange&quot;);

        // Accessing elements
        System.out.println(&quot;Fruits: &quot; + fruits);

        // Iterating through elements using Iterator
        Iterator&lt;String&gt; iterator = fruits.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

        // Updating an element
        fruits.set(1, &quot;Mango&quot;);
        System.out.println(&quot;Updated Fruits: &quot; + fruits);

        // Removing an element
        fruits.remove(&quot;Apple&quot;);
        System.out.println(&quot;Fruits after removal: &quot; + fruits);

        // Checking if a specific element exists
        if (fruits.contains(&quot;Orange&quot;)) {
            System.out.println(&quot;Orange is present in the list.&quot;);
        }

        // Getting the size of the vector
        System.out.println(&quot;Size of the vector: &quot; + fruits.size());
    }
}
</div></section><section class="chapter"><h3 id="explanation" data-toc="explanation"   >Explanation:</h3><ul class="list _ul" id="b7332e06_90"><li class="list__item" id="b7332e06_91"><p id="b7332e06_92"><span class="control" id="b7332e06_93">Creation:</span> Use the <code class="code" id="b7332e06_94">Vector</code> class to create a dynamic array capable of resizing itself.</p></li><li class="list__item" id="b7332e06_95"><p id="b7332e06_96"><span class="control" id="b7332e06_97">Adding Elements:</span> Employ the <code class="code" id="b7332e06_98">add()</code> method to insert elements into the vector.</p></li><li class="list__item" id="b7332e06_99"><p id="b7332e06_100"><span class="control" id="b7332e06_101">Accessing Elements:</span> Directly access elements using their index or utilize an iterator for sequential access.</p></li><li class="list__item" id="b7332e06_102"><p id="b7332e06_103"><span class="control" id="b7332e06_104">Updating Elements:</span> Modify elements at a specific index with the <code class="code" id="b7332e06_105">set()</code> method.</p></li><li class="list__item" id="b7332e06_106"><p id="b7332e06_107"><span class="control" id="b7332e06_108">Removing Elements:</span> Remove elements using <code class="code" id="b7332e06_109">remove()</code> based on either the index or the object itself.</p></li><li class="list__item" id="b7332e06_110"><p id="b7332e06_111"><span class="control" id="b7332e06_112">Checking Existence:</span> Verify if a specific element exists with the <code class="code" id="b7332e06_113">contains()</code> method.</p></li><li class="list__item" id="b7332e06_114"><p id="b7332e06_115"><span class="control" id="b7332e06_116">Size of Vector:</span> Retrieve the size of the vector using the <code class="code" id="b7332e06_117">size()</code> method.</p></li></ul><p id="b7332e06_118">Note: While Vectors provide synchronization, if thread safety is not a concern, consider using ArrayList for better performance.</p></section></section><section class="chapter"><h2 id="6-understanding-the-java-stack" data-toc="6-understanding-the-java-stack"   >6. Understanding the Java Stack</h2><p id="b7332e06_119">In Java, a stack is a data structure that follows the Last In, First Out (LIFO) principle. It means that the last element added to the stack is the first one to be removed. Java provides a built-in class called <code class="code" id="b7332e06_120">Stack</code> that implements this data structure. Let's explore the concept of a stack in Java with some examples.</p><section class="chapter"><h3 id="example-1-basic-stack-operations" data-toc="example-1-basic-stack-operations"   >Example 1: Basic Stack Operations</h3><div class="code-block" data-lang="java"         >
import java.util.Stack;

public class StackExample {

    public static void main(String[] args) {
        // Creating a stack
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        // Pushing elements onto the stack
        stack.push(&quot;Java&quot;);
        stack.push(&quot;Python&quot;);
        stack.push(&quot;C++&quot;);

        // Pop an element from the stack
        String poppedElement = stack.pop();
        System.out.println(&quot;Popped Element: &quot; + poppedElement);

        // Peek at the top element without removing it
        String topElement = stack.peek();
        System.out.println(&quot;Top Element: &quot; + topElement);

        // Check if the stack is empty
        boolean isEmpty = stack.isEmpty();
        System.out.println(&quot;Is Stack Empty? &quot; + isEmpty);
    }
}
</div></section><section class="chapter"><h3 id="example-2-using-stack-for-expression-evaluation" data-toc="example-2-using-stack-for-expression-evaluation"   >Example 2: Using Stack for Expression Evaluation</h3><div class="code-block" data-lang="java"         >
import java.util.Stack;

public class ExpressionEvaluation {

    public static int evaluateExpression(String expression) {
        Stack&lt;Integer&gt; operandStack = new Stack&lt;&gt;();

        for (char ch : expression.toCharArray()) {
            if (Character.isDigit(ch)) {
                operandStack.push(Character.getNumericValue(ch));
            } else {
                int operand2 = operandStack.pop();
                int operand1 = operandStack.pop();
                int result = performOperation(operand1, operand2, ch);
                operandStack.push(result);
            }
        }

        return operandStack.pop();
    }

    private static int performOperation(int operand1, int operand2, char operator) {
        switch (operator) {
            case '+':
                return operand1 + operand2;
            case '-':
                return operand1 - operand2;
            case '*':
                return operand1 * operand2;
            case '/':
                return operand1 / operand2;
            default:
                throw new IllegalArgumentException(&quot;Invalid operator: &quot; + operator);
        }
    }

    public static void main(String[] args) {
        String expression = &quot;52*3+&quot;;
        int result = evaluateExpression(expression);
        System.out.println(&quot;Result of the expression &quot; + expression + &quot;: &quot; + result);
    }
}
</div><p id="b7332e06_123">These examples illustrate the basic usage of the <code class="code" id="b7332e06_124">Stack</code> class in Java, including pushing and popping elements, peeking at the top element, and implementing a simple expression evaluation algorithm using a stack. Understanding and leveraging stacks can be valuable in various scenarios, such as parsing expressions, managing function calls, and solving certain algorithmic problems.</p></section></section><section class="chapter"><h2 id="7-understanding-collections-in-java" data-toc="7-understanding-collections-in-java"   >7. Understanding Collections in Java</h2><p id="b7332e06_125">Java Collections Framework provides a set of interfaces and classes to manipulate and store groups of objects. It simplifies the task of managing collections of objects, offering a wide range of data structures like lists, sets, queues, and maps. Collections play a crucial role in Java programming, enhancing the efficiency and flexibility of handling data.</p><p id="b7332e06_126"><span class="control" id="b7332e06_127">Examples:</span></p><ol class="list _decimal" id="b7332e06_128" type="1"><li class="list__item" id="b7332e06_129"><p id="b7332e06_130"><span class="control" id="b7332e06_131">List Interface:</span></p><ul class="list _ul" id="b7332e06_132"><li class="list__item" id="b7332e06_133"><p>The <code class="code" id="b7332e06_134">List</code> interface represents an ordered collection and allows duplicate elements. Example implementations include <code class="code" id="b7332e06_135">ArrayList</code> and <code class="code" id="b7332e06_136">LinkedList</code>.</p></li></ul><div class="code-block" data-lang="java"         >
List&lt;String&gt; names = new ArrayList&lt;&gt;();
names.add(&quot;Alice&quot;);
names.add(&quot;Bob&quot;);
names.add(&quot;Charlie&quot;);

System.out.println(&quot;Names: &quot; + names);
</div></li><li class="list__item" id="b7332e06_138"><p id="b7332e06_139"><span class="control" id="b7332e06_140">Set Interface:</span></p><ul class="list _ul" id="b7332e06_141"><li class="list__item" id="b7332e06_142"><p>The <code class="code" id="b7332e06_143">Set</code> interface represents an unordered collection that doesn't allow duplicate elements. Example implementations include <code class="code" id="b7332e06_144">HashSet</code> and <code class="code" id="b7332e06_145">TreeSet</code>.</p></li></ul><div class="code-block" data-lang="java"         >
Set&lt;Integer&gt; numbers = new HashSet&lt;&gt;();
numbers.add(1);
numbers.add(2);
numbers.add(3);
numbers.add(2); // Duplicate, won't be added

System.out.println(&quot;Numbers: &quot; + numbers);
</div></li><li class="list__item" id="b7332e06_147"><p id="b7332e06_148"><span class="control" id="b7332e06_149">Map Interface:</span></p><ul class="list _ul" id="b7332e06_150"><li class="list__item" id="b7332e06_151"><p>The <code class="code" id="b7332e06_152">Map</code> interface represents a collection of key-value pairs. Example implementations include <code class="code" id="b7332e06_153">HashMap</code> and <code class="code" id="b7332e06_154">TreeMap</code>.</p></li></ul><div class="code-block" data-lang="java"         >
Map&lt;String, Integer&gt; ages = new HashMap&lt;&gt;();
ages.put(&quot;Alice&quot;, 25);
ages.put(&quot;Bob&quot;, 30);
ages.put(&quot;Charlie&quot;, 22);

System.out.println(&quot;Ages: &quot; + ages);
</div></li><li class="list__item" id="b7332e06_156"><p id="b7332e06_157"><span class="control" id="b7332e06_158">Queue Interface:</span></p><ul class="list _ul" id="b7332e06_159"><li class="list__item" id="b7332e06_160"><p>The <code class="code" id="b7332e06_161">Queue</code> interface represents a collection designed for holding elements before processing. Example implementations include <code class="code" id="b7332e06_162">LinkedList</code> and <code class="code" id="b7332e06_163">PriorityQueue</code>.</p></li></ul><div class="code-block" data-lang="java"         >
Queue&lt;String&gt; tasks = new LinkedList&lt;&gt;();
tasks.add(&quot;Task 1&quot;);
tasks.add(&quot;Task 2&quot;);
tasks.add(&quot;Task 3&quot;);

System.out.println(&quot;Tasks: &quot; + tasks);
</div></li><li class="list__item" id="b7332e06_165"><p id="b7332e06_166"><span class="control" id="b7332e06_167">Collections Utility Class:</span></p><ul class="list _ul" id="b7332e06_168"><li class="list__item" id="b7332e06_169"><p>The <code class="code" id="b7332e06_170">Collections</code> class provides various utility methods for manipulating collections, like sorting, shuffling, and finding the maximum element.</p></li></ul><div class="code-block" data-lang="java"         >
List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 8, 1, 3);
Collections.sort(numbers);

System.out.println(&quot;Sorted Numbers: &quot; + numbers);
</div></li></ol><p id="b7332e06_172">Understanding and effectively using the Java Collections Framework is crucial for developing robust and efficient applications. It allows developers to choose the right data structure for their needs and enhances code readability and maintainability.</p></section><section class="chapter"><h2 id="8-understanding-java-s-deque-interface" data-toc="8-understanding-java-s-deque-interface"   >8. Understanding Java's Deque Interface</h2><p id="b7332e06_173">Java's <code class="code" id="b7332e06_174">Deque</code> (Double Ended Queue) interface is a part of the Java Collections Framework and extends the <code class="code" id="b7332e06_175">Queue</code> interface. It represents a double-ended queue, meaning that you can insert and remove elements from both ends of the queue. The <code class="code" id="b7332e06_176">Deque</code> interface provides methods for operations such as adding, removing, and inspecting elements, allowing for versatile use cases.</p><p id="b7332e06_177">Here is a brief explanation of some key methods in the <code class="code" id="b7332e06_178">Deque</code> interface along with examples:</p><section class="chapter"><h3 id="1-adding-elements" data-toc="1-adding-elements"   >1. Adding Elements:</h3><ul class="list _ul" id="b7332e06_179"><li class="list__item" id="b7332e06_180"><p id="b7332e06_181"><code class="code" id="b7332e06_182">addFirst(E e)</code> and <code class="code" id="b7332e06_183">addLast(E e)</code>: These methods add elements to the front and rear of the deque, respectively.</p><div class="code-block" data-lang="java"         >
Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();
deque.addFirst(&quot;First&quot;);
deque.addLast(&quot;Last&quot;);
</div></li></ul></section><section class="chapter"><h3 id="2-removing-elements" data-toc="2-removing-elements"   >2. Removing Elements:</h3><ul class="list _ul" id="b7332e06_185"><li class="list__item" id="b7332e06_186"><p id="b7332e06_187"><code class="code" id="b7332e06_188">removeFirst()</code> and <code class="code" id="b7332e06_189">removeLast()</code>: These methods remove and return the first and last elements of the deque.</p><div class="code-block" data-lang="java"         >
String firstElement = deque.removeFirst();
String lastElement = deque.removeLast();
</div></li></ul></section><section class="chapter"><h3 id="3-retrieving-elements" data-toc="3-retrieving-elements"   >3. Retrieving Elements:</h3><ul class="list _ul" id="b7332e06_191"><li class="list__item" id="b7332e06_192"><p id="b7332e06_193"><code class="code" id="b7332e06_194">getFirst()</code> and <code class="code" id="b7332e06_195">getLast()</code>: These methods retrieve, but do not remove, the first and last elements of the deque.</p><div class="code-block" data-lang="java"         >
String firstElement = deque.getFirst();
String lastElement = deque.getLast();
</div></li></ul></section><section class="chapter"><h3 id="4-checking-size-and-empty-status" data-toc="4-checking-size-and-empty-status"   >4. Checking Size and Empty Status:</h3><ul class="list _ul" id="b7332e06_197"><li class="list__item" id="b7332e06_198"><p id="b7332e06_199"><code class="code" id="b7332e06_200">size()</code>: Returns the number of elements in the deque.</p></li><li class="list__item" id="b7332e06_201"><p id="b7332e06_202"><code class="code" id="b7332e06_203">isEmpty()</code>: Returns true if the deque is empty.</p><div class="code-block" data-lang="java"         >
int dequeSize = deque.size();
boolean isEmpty = deque.isEmpty();
</div></li></ul></section><section class="chapter"><h3 id="example_1" data-toc="example_1"   >Example:</h3><div class="code-block" data-lang="java"         >
import java.util.Deque;
import java.util.LinkedList;

public class DequeExample {
    public static void main(String[] args) {
        // Creating a Deque
        Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();

        // Adding elements
        deque.addFirst(&quot;First&quot;);
        deque.addLast(&quot;Last&quot;);

        // Removing elements
        String firstElement = deque.removeFirst();
        String lastElement = deque.removeLast();

        // Retrieving elements
        String peekFirst = deque.getFirst();
        String peekLast = deque.getLast();

        // Checking size and emptiness
        int dequeSize = deque.size();
        boolean isEmpty = deque.isEmpty();
    }
}
</div><p id="b7332e06_206">This example demonstrates basic operations with a <code class="code" id="b7332e06_207">Deque</code>, showcasing how to add, remove, retrieve elements, and check the size and emptiness of the deque. The actual implementation of the <code class="code" id="b7332e06_208">Deque</code> interface can be done using classes like <code class="code" id="b7332e06_209">LinkedList</code> or <code class="code" id="b7332e06_210">ArrayDeque</code> in Java.</p></section></section><section class="chapter"><h2 id="9-understanding-the-java-map-interface" data-toc="9-understanding-the-java-map-interface"   >9. Understanding the Java Map Interface</h2><p id="b7332e06_211">Java Map Interface: The Map interface in Java is a part of the Java Collections Framework and is designed to store key-value pairs. It represents a collection of elements where each element is a pair of keys and values. Unlike a List, which is indexed by integers, a Map is indexed by keys. It does not allow duplicate keys and each key is associated with exactly one value.</p><p id="b7332e06_212">Commonly used classes that implement the Map interface in Java are HashMap, TreeMap, and LinkedHashMap.</p><p id="b7332e06_213">Example 1: HashMap</p><div class="code-block" data-lang="java"         >
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        // Creating a HashMap
        Map&lt;String, Integer&gt; studentScores = new HashMap&lt;&gt;();

        // Adding key-value pairs
        studentScores.put(&quot;Alice&quot;, 85);
        studentScores.put(&quot;Bob&quot;, 92);
        studentScores.put(&quot;Charlie&quot;, 78);

        // Accessing values by key
        System.out.println(&quot;Bob's score: &quot; + studentScores.get(&quot;Bob&quot;));

        // Iterating through the map
        for (Map.Entry&lt;String, Integer&gt; entry : studentScores.entrySet()) {
            System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());
        }
    }
}
</div><p id="b7332e06_215">Example 2: TreeMap</p><div class="code-block" data-lang="java"         >
import java.util.Map;
import java.util.TreeMap;

public class TreeMapExample {
    public static void main(String[] args) {
        // Creating a TreeMap
        Map&lt;String, Integer&gt; monthDays = new TreeMap&lt;&gt;();

        // Adding key-value pairs
        monthDays.put(&quot;January&quot;, 31);
        monthDays.put(&quot;February&quot;, 28);
        monthDays.put(&quot;March&quot;, 31);

        // Accessing values by key
        System.out.println(&quot;Days in February: &quot; + monthDays.get(&quot;February&quot;));

        // Iterating through the map
        for (Map.Entry&lt;String, Integer&gt; entry : monthDays.entrySet()) {
            System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue() + &quot; days&quot;);
        }
    }
}
</div><p id="b7332e06_217">In these examples, HashMap is used for general-purpose key-value storage, while TreeMap is used when a sorted order of keys is required. The Map interface provides a powerful and flexible way to work with key-value pairs in Java.</p></section><section class="chapter"><h2 id="10-understanding-hashmap-in-java" data-toc="10-understanding-hashmap-in-java"   >10. Understanding HashMap in Java</h2><p id="b7332e06_218">HashMap is a crucial data structure in Java that provides a way to store and retrieve key-value pairs. It belongs to the Java Collections Framework and is part of the <code class="code" id="b7332e06_219">java.util</code> package. HashMap uses a hashing mechanism to efficiently store and retrieve elements based on their keys.</p><section class="chapter"><h3 id="basic-structure" data-toc="basic-structure"   >Basic Structure:</h3><div class="code-block" data-lang="java"         >
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        // Creating a HashMap
        HashMap&lt;String, Integer&gt; studentScores = new HashMap&lt;&gt;();

        // Adding key-value pairs
        studentScores.put(&quot;Alice&quot;, 90);
        studentScores.put(&quot;Bob&quot;, 85);
        studentScores.put(&quot;Charlie&quot;, 95);

        // Accessing values
        int bobScore = studentScores.get(&quot;Bob&quot;);
        System.out.println(&quot;Bob's Score: &quot; + bobScore);

        // Iterating through the HashMap
        for (String name : studentScores.keySet()) {
            int score = studentScores.get(name);
            System.out.println(name + &quot;: &quot; + score);
        }
    }
}
</div></section><section class="chapter"><h3 id="explanation_1" data-toc="explanation_1"   >Explanation:</h3><ol class="list _decimal" id="b7332e06_221" type="1"><li class="list__item" id="b7332e06_222"><p id="b7332e06_223"><span class="control" id="b7332e06_224">Creating a HashMap:</span></p><ul class="list _ul" id="b7332e06_225"><li class="list__item" id="b7332e06_226"><p>You create a HashMap using the <code class="code" id="b7332e06_227">HashMap</code> class. In the example, <code class="code" id="b7332e06_228">HashMap&lt;String, Integer&gt;</code> means keys are of type String, and values are of type Integer.</p></li></ul></li><li class="list__item" id="b7332e06_229"><p id="b7332e06_230"><span class="control" id="b7332e06_231">Adding Key-Value Pairs:</span></p><ul class="list _ul" id="b7332e06_232"><li class="list__item" id="b7332e06_233"><p>The <code class="code" id="b7332e06_234">put(key, value)</code> method is used to add key-value pairs to the HashMap.</p></li></ul></li><li class="list__item" id="b7332e06_235"><p id="b7332e06_236"><span class="control" id="b7332e06_237">Accessing Values:</span></p><ul class="list _ul" id="b7332e06_238"><li class="list__item" id="b7332e06_239"><p>The <code class="code" id="b7332e06_240">get(key)</code> method allows you to retrieve the value associated with a specific key.</p></li></ul></li><li class="list__item" id="b7332e06_241"><p id="b7332e06_242"><span class="control" id="b7332e06_243">Iterating through the HashMap:</span></p><ul class="list _ul" id="b7332e06_244"><li class="list__item" id="b7332e06_245"><p>You can use <code class="code" id="b7332e06_246">keySet()</code> to obtain a set of keys, and then iterate through the keys to access corresponding values.</p></li></ul></li></ol></section><section class="chapter"><h3 id="key-features" data-toc="key-features"   >Key Features:</h3><ul class="list _ul" id="b7332e06_247"><li class="list__item" id="b7332e06_248"><p id="b7332e06_249"><span class="control" id="b7332e06_250">Uniqueness of Keys:</span></p><ul class="list _ul" id="b7332e06_251"><li class="list__item" id="b7332e06_252"><p>Each key in a HashMap must be unique. If you try to add a duplicate key with a different value, it will overwrite the existing value.</p></li></ul></li><li class="list__item" id="b7332e06_253"><p id="b7332e06_254"><span class="control" id="b7332e06_255">Null Values:</span></p><ul class="list _ul" id="b7332e06_256"><li class="list__item" id="b7332e06_257"><p>HashMap allows null values and one null key.</p></li></ul></li><li class="list__item" id="b7332e06_258"><p id="b7332e06_259"><span class="control" id="b7332e06_260">Performance:</span></p><ul class="list _ul" id="b7332e06_261"><li class="list__item" id="b7332e06_262"><p>HashMap provides constant-time performance for basic operations like <code class="code" id="b7332e06_263">get()</code> and <code class="code" id="b7332e06_264">put()</code>.</p></li></ul></li><li class="list__item" id="b7332e06_265"><p id="b7332e06_266"><span class="control" id="b7332e06_267">Ordering:</span></p><ul class="list _ul" id="b7332e06_268"><li class="list__item" id="b7332e06_269"><p>The order of key-value pairs in a HashMap is not guaranteed. If you need ordered key-value pairs, consider using <code class="code" id="b7332e06_270">LinkedHashMap</code>.</p></li></ul></li></ul><p id="b7332e06_271">Understanding HashMaps is essential for efficient data storage and retrieval in Java, especially when dealing with large datasets.</p></section></section><section class="chapter"><h2 id="11-understanding-hashset-in-java" data-toc="11-understanding-hashset-in-java"   >11. Understanding HashSet in Java</h2><p id="b7332e06_272">HashSet in Java is a part of the Java Collections Framework and is an implementation of the Set interface. It is used to store a collection of unique elements. HashSet does not guarantee the order of elements and allows for efficient retrieval and storage of elements.</p><section class="chapter"><h3 id="examples" data-toc="examples"   >Examples:</h3><section class="chapter"><h4 id="1-creating-a-hashset" data-toc="1-creating-a-hashset"   >1. Creating a HashSet:</h4><div class="code-block" data-lang="java"         >
import java.util.HashSet;

public class HashSetExample {
    public static void main(String[] args) {
        // Creating a HashSet
        HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();

        // Adding elements to the HashSet
        hashSet.add(&quot;Apple&quot;);
        hashSet.add(&quot;Banana&quot;);
        hashSet.add(&quot;Orange&quot;);
        hashSet.add(&quot;Apple&quot;);  // Duplicate element, will not be added

        System.out.println(&quot;HashSet: &quot; + hashSet);
    }
}
</div><p id="b7332e06_274">Output:</p><div class="code-block" data-lang="none"         >
HashSet: [Orange, Banana, Apple]
</div></section><section class="chapter"><h4 id="2-hashset-operations" data-toc="2-hashset-operations"   >2. HashSet Operations:</h4><div class="code-block" data-lang="java"         >
import java.util.HashSet;

public class HashSetOperations {
    public static void main(String[] args) {
        // Creating HashSet1
        HashSet&lt;String&gt; set1 = new HashSet&lt;&gt;();
        set1.add(&quot;Java&quot;);
        set1.add(&quot;Python&quot;);
        set1.add(&quot;C++&quot;);

        // Creating HashSet2
        HashSet&lt;String&gt; set2 = new HashSet&lt;&gt;();
        set2.add(&quot;Python&quot;);
        set2.add(&quot;JavaScript&quot;);
        set2.add(&quot;Java&quot;);

        // Union of two HashSets
        HashSet&lt;String&gt; union = new HashSet&lt;&gt;(set1);
        union.addAll(set2);
        System.out.println(&quot;Union: &quot; + union);

        // Intersection of two HashSets
        HashSet&lt;String&gt; intersection = new HashSet&lt;&gt;(set1);
        intersection.retainAll(set2);
        System.out.println(&quot;Intersection: &quot; + intersection);

        // Difference of two HashSets
        HashSet&lt;String&gt; difference = new HashSet&lt;&gt;(set1);
        difference.removeAll(set2);
        System.out.println(&quot;Difference: &quot; + difference);
    }
}
</div><p id="b7332e06_277">Output:</p><div class="code-block" data-lang="none"         >
Union: [Python, JavaScript, C++, Java]
Intersection: [Java, Python]
Difference: [C++]
</div><p id="b7332e06_279">In the examples above, we demonstrate creating a HashSet, adding elements to it (where duplicate elements are automatically removed), and performing set operations like union, intersection, and difference on two HashSet instances. These operations showcase the flexibility and usefulness of HashSet in Java.</p></section></section></section><section class="chapter"><h2 id="12-understanding-sets-in-java" data-toc="12-understanding-sets-in-java"   >12. Understanding Sets in Java</h2><p id="b7332e06_280">Introduction: In Java, a Set is a collection that does not allow duplicate elements. It models the mathematical set abstraction and is part of the Java Collections Framework. Sets provide methods for basic set operations, such as union, intersection, and difference. The key implementations of the Set interface in Java are HashSet, TreeSet, and LinkedHashSet.</p><p id="b7332e06_281">Example 1: HashSet</p><div class="code-block" data-lang="java"         >
import java.util.HashSet;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args) {
        // Creating a HashSet
        Set&lt;String&gt; set = new HashSet&lt;&gt;();

        // Adding elements to the set
        set.add(&quot;Apple&quot;);
        set.add(&quot;Banana&quot;);
        set.add(&quot;Orange&quot;);
        set.add(&quot;Apple&quot;); // Duplicate element, not added

        // Displaying the elements of the set
        System.out.println(&quot;HashSet: &quot; + set);
    }
}
</div><p id="b7332e06_283">Example 2: TreeSet</p><div class="code-block" data-lang="java"         >
import java.util.Set;
import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Creating a TreeSet
        Set&lt;String&gt; set = new TreeSet&lt;&gt;();

        // Adding elements to the set
        set.add(&quot;Orange&quot;);
        set.add(&quot;Banana&quot;);
        set.add(&quot;Apple&quot;);

        // Displaying the elements of the set (naturally ordered)
        System.out.println(&quot;TreeSet: &quot; + set);
    }
}
</div><p id="b7332e06_285">Example 3: LinkedHashSet</p><div class="code-block" data-lang="java"         >
import java.util.Set;
import java.util.LinkedHashSet;

public class LinkedHashSetExample {
    public static void main(String[] args) {
        // Creating a LinkedHashSet
        Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();

        // Adding elements to the set
        set.add(&quot;Orange&quot;);
        set.add(&quot;Banana&quot;);
        set.add(&quot;Apple&quot;);

        // Displaying the elements of the set (insertion order)
        System.out.println(&quot;LinkedHashSet: &quot; + set);
    }
}
</div><p id="b7332e06_287">Conclusion: Sets in Java provide a versatile way to store unique elements efficiently. Depending on the use case, you can choose between HashSet for fast access, TreeSet for natural ordering, or LinkedHashSet for maintaining insertion order. Incorporating set operations into your code can lead to cleaner and more efficient implementations.</p></section><section class="chapter"><h2 id="13-understanding-java-s-queue-interface" data-toc="13-understanding-java-s-queue-interface"   >13. Understanding Java's Queue Interface</h2><p id="b7332e06_288">Java's <code class="code" id="b7332e06_289">Queue&lt;E&gt;</code> interface is a part of the Java Collections Framework and represents a collection of elements arranged in a specific order. The Queue interface extends the Collection interface and adds methods for insertion, extraction, and inspection of elements in a first-in, first-out (FIFO) manner.</p><p id="b7332e06_290">Here is a brief explanation of the key methods provided by the <code class="code" id="b7332e06_291">Queue&lt;E&gt;</code> interface:</p><ol class="list _decimal" id="b7332e06_292" type="1"><li class="list__item" id="b7332e06_293"><p><span class="control" id="b7332e06_294"><code class="code" id="b7332e06_295">offer(E e)</code></span>: Adds the specified element to the end of the queue if space allows.</p></li><li class="list__item" id="b7332e06_296"><p><span class="control" id="b7332e06_297"><code class="code" id="b7332e06_298">poll()</code></span>: Retrieves and removes the head of the queue, returning null if the queue is empty.</p></li><li class="list__item" id="b7332e06_299"><p><span class="control" id="b7332e06_300"><code class="code" id="b7332e06_301">peek()</code></span>: Retrieves the head of the queue without removing it, returning null if the queue is empty.</p></li></ol><p id="b7332e06_302">Now, let's see an example of using <code class="code" id="b7332e06_303">Queue&lt;E&gt;</code> in Java:</p><div class="code-block" data-lang="java"         >
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        // Creating a Queue using LinkedList
        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

        // Adding elements to the queue
        queue.offer(&quot;Element 1&quot;);
        queue.offer(&quot;Element 2&quot;);
        queue.offer(&quot;Element 3&quot;);

        System.out.println(&quot;Queue: &quot; + queue);

        // Removing and displaying the head of the queue
        String head = queue.poll();
        System.out.println(&quot;Removed Element: &quot; + head);
        System.out.println(&quot;Updated Queue: &quot; + queue);

        // Peeking at the head without removing it
        String peekedElement = queue.peek();
        System.out.println(&quot;Peeked Element: &quot; + peekedElement);
        System.out.println(&quot;Queue after Peek: &quot; + queue);
    }
}
</div><p id="b7332e06_305">In this example, a <code class="code" id="b7332e06_306">LinkedList</code> is used to implement the <code class="code" id="b7332e06_307">Queue</code> interface. Elements are added to the queue using the <code class="code" id="b7332e06_308">offer()</code> method, and the <code class="code" id="b7332e06_309">poll()</code> and <code class="code" id="b7332e06_310">peek()</code> methods are used to retrieve and inspect elements, respectively. The output demonstrates the FIFO behavior of the queue.</p><p id="b7332e06_311">The <code class="code" id="b7332e06_312">Queue&lt;E&gt;</code> interface is particularly useful in scenarios where you need to process elements in the order they were added, such as task scheduling, breadth-first search, or any situation where the order of processing is crucial.</p></section><section class="chapter"><h2 id="14-java-dictionary-k-v" data-toc="14-java-dictionary-k-v"   >14. Java Dictionary&lt;K, V&gt;</h2><p id="b7332e06_313">In Java, the <code class="code" id="b7332e06_314">Dictionary&lt;K, V&gt;</code> interface is a part of the <code class="code" id="b7332e06_315">java.util</code> package and represents a collection of key-value pairs where keys and values are both objects. It is an abstract class and is the superclass of any class that implements a mapping of keys to values.</p><p id="b7332e06_316">Here's a breakdown of its key components:</p><ul class="list _ul" id="b7332e06_317"><li class="list__item" id="b7332e06_318"><p><span class="control" id="b7332e06_319">K</span>: Represents the type of keys.</p></li><li class="list__item" id="b7332e06_320"><p><span class="control" id="b7332e06_321">V</span>: Represents the type of values.</p></li></ul><section class="chapter"><h3 id="example-usage_1" data-toc="example-usage_1"   >Example Usage:</h3><p id="b7332e06_322">Let's create a simple example using <code class="code" id="b7332e06_323">Hashtable</code>, a concrete implementation of <code class="code" id="b7332e06_324">Dictionary</code>.</p><div class="code-block" data-lang="java"         >
import java.util.Dictionary;
import java.util.Hashtable;

public class DictionaryExample {
    public static void main(String[] args) {
        // Creating a Dictionary with String keys and Integer values
        Dictionary&lt;String, Integer&gt; studentScores = new Hashtable&lt;&gt;();

        // Adding key-value pairs
        studentScores.put(&quot;Alice&quot;, 95);
        studentScores.put(&quot;Bob&quot;, 87);
        studentScores.put(&quot;Charlie&quot;, 92);

        // Accessing values by key
        int bobScore = studentScores.get(&quot;Bob&quot;);
        System.out.println(&quot;Bob's Score: &quot; + bobScore);

        // Checking if a key exists
        if (studentScores.containsKey(&quot;Alice&quot;)) {
            System.out.println(&quot;Alice's Score: &quot; + studentScores.get(&quot;Alice&quot;));
        }

        // Displaying all keys and values
        System.out.println(&quot;All Student Scores:&quot;);
        for (String student : studentScores.keys()) {
            System.out.println(student + &quot;: &quot; + studentScores.get(student));
        }
    }
}
</div><p id="b7332e06_326">In this example, we use a <code class="code" id="b7332e06_327">Hashtable</code> to implement the <code class="code" id="b7332e06_328">Dictionary</code> interface. We create a dictionary (<code class="code" id="b7332e06_329">studentScores</code>) with keys of type <code class="code" id="b7332e06_330">String</code> and values of type <code class="code" id="b7332e06_331">Integer</code>. We then add key-value pairs, retrieve values by keys, check for key existence, and iterate through all key-value pairs.</p><p id="b7332e06_332">Using <code class="code" id="b7332e06_333">Dictionary</code> provides a generic way to handle key-value mappings, and different concrete implementations can be used based on specific requirements.</p><p id="b7332e06_334">Remember that <code class="code" id="b7332e06_335">Hashtable</code> is synchronized, but if you don't need thread-safety, you might prefer to use <code class="code" id="b7332e06_336">HashMap</code> instead for better performance in a non-threaded environment.</p></section></section><section class="chapter"><h2 id="15-understanding-hashtable-in-java" data-toc="15-understanding-hashtable-in-java"   >15. Understanding Hashtable in Java</h2><p id="b7332e06_337">A Hashtable in Java is a data structure that stores key-value pairs, where each key is mapped to a specific value. It is part of the Java Collections Framework and provides efficient retrieval and storage of data. The underlying mechanism involves using a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.</p><p id="b7332e06_338">Here's a simple example to illustrate how to use Hashtable in Java:</p><div class="code-block" data-lang="java"         >
import java.util.Hashtable;

public class HashtableExample {

    public static void main(String[] args) {
        // Creating a Hashtable instance
        Hashtable&lt;String, Integer&gt; studentScores = new Hashtable&lt;&gt;();

        // Adding key-value pairs to the Hashtable
        studentScores.put(&quot;Alice&quot;, 90);
        studentScores.put(&quot;Bob&quot;, 85);
        studentScores.put(&quot;Charlie&quot;, 95);
        studentScores.put(&quot;David&quot;, 88);

        // Retrieving values using keys
        int scoreBob = studentScores.get(&quot;Bob&quot;);
        System.out.println(&quot;Bob's score: &quot; + scoreBob);

        // Updating a value
        studentScores.put(&quot;Charlie&quot;, 97);

        // Removing a key-value pair
        studentScores.remove(&quot;David&quot;);

        // Displaying all key-value pairs
        System.out.println(&quot;Student Scores:&quot;);
        for (String name : studentScores.keySet()) {
            int score = studentScores.get(name);
            System.out.println(name + &quot;: &quot; + score);
        }
    }
}
</div><p id="b7332e06_340">In this example, a Hashtable named <code class="code" id="b7332e06_341">studentScores</code> is created to store scores for different students. Key-value pairs are added using the <code class="code" id="b7332e06_342">put</code> method, and values are retrieved using the <code class="code" id="b7332e06_343">get</code> method. The code also demonstrates updating a value, removing a key-value pair, and iterating through all key-value pairs.</p><p id="b7332e06_344">Hashtable provide constant-time average complexity for basic operations like get, put, and remove, making them suitable for applications that require fast access to data based on keys. However, it's important to handle collisions ( situations where different keys hash to the same index) to ensure the proper functioning of the Hashtable.</p></section><div class="last-modified"> Last modified: 27 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="streams-api.html">Streams API</a>   <a class="navigation-links__next" href="python-language.html">Python Language</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>