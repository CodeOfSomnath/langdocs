<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2024-01-23T01:31:58.4877725"><meta name="build-number" content="${buildNumber}">       <title>Function Pointers | Language Learning Path</title><script id="virtual-toc-data" type="application/json">[{"id":"1-introduction","level":0,"title":"1. Introduction","anchor":"#1-introduction"},{"id":"2-simple-function-pointer","level":0,"title":"2. Simple Function Pointer","anchor":"#2-simple-function-pointer"},{"id":"3-function-pointer-without-parameters","level":0,"title":"3. Function Pointer without Parameters","anchor":"#3-function-pointer-without-parameters"},{"id":"4-function-pointer-with-void-pointer-parameters","level":0,"title":"4. Function Pointer with Void Pointer Parameters","anchor":"#4-function-pointer-with-void-pointer-parameters"},{"id":"5-array-of-function-pointers","level":0,"title":"5. Array of Function Pointers","anchor":"#5-array-of-function-pointers"},{"id":"6-function-pointer-as-a-parameter","level":0,"title":"6. Function Pointer as a Parameter","anchor":"#6-function-pointer-as-a-parameter"},{"id":"7-function-pointer-as-a-return-type","level":0,"title":"7. Function Pointer as a Return Type","anchor":"#7-function-pointer-as-a-return-type"},{"id":"8-callback-functions","level":0,"title":"8. Callback Functions","anchor":"#8-callback-functions"},{"id":"9-generic-function-pointers","level":0,"title":"9. Generic Function Pointers","anchor":"#9-generic-function-pointers"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Function Pointers | Language Learning Path"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Language Learning Path Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="function-pointers.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Function Pointers | Language Learning Path"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "function-pointers.html#webpage", "url": "function-pointers.html", "name": "Function Pointers | Language Learning Path", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Language Learning Path Help" }</script><!-- End Schema.org --></head>      <body data-id="Function-Pointers" data-main-title="Function Pointers" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="C-language.md|C language"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Language Learning Path  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Function-Pointers"   id="Function-Pointers.md">Function Pointers</h1>  <section class="chapter"><h2 id="1-introduction" data-toc="1-introduction"   >1. Introduction</h2><p id="822366c6_912">In C, function pointers are variables that can store addresses of functions. They allow you to create more flexible and dynamic code by enabling you to pass functions as arguments to other functions, return functions from functions, and store functions in data structures. There are different types of function pointers in C, depending on the function signature they point to. Here are some common types:</p><ol class="list _decimal" id="822366c6_913" type="1"><li class="list__item" id="822366c6_914"><p id="822366c6_915"><span class="control" id="822366c6_916">Simple Function Pointer:</span></p><ul class="list _ul" id="822366c6_917"><li class="list__item" id="822366c6_918"><p id="822366c6_919">This is the most basic type of function pointer.</p></li><li class="list__item" id="822366c6_920"><p id="822366c6_921">It points to a function with a specific signature.</p></li><li class="list__item" id="822366c6_922"><p id="822366c6_923">Example:</p><div class="code-block" data-lang="c"         >
int (*ptr)(int, int); // Pointer to a function taking two ints and returning an int
</div></li></ul></li><li class="list__item" id="822366c6_925"><p id="822366c6_926"><span class="control" id="822366c6_927">Function Pointer without Parameters:</span></p><ul class="list _ul" id="822366c6_928"><li class="list__item" id="822366c6_929"><p id="822366c6_930">Points to a function that doesn't take any parameters.</p></li><li class="list__item" id="822366c6_931"><p id="822366c6_932">Example:</p><div class="code-block" data-lang="c"         >
void (*ptr)(); // Pointer to a function taking no parameters
</div></li></ul></li><li class="list__item" id="822366c6_934"><p id="822366c6_935"><span class="control" id="822366c6_936">Function Pointer with Void Pointer Parameters:</span></p><ul class="list _ul" id="822366c6_937"><li class="list__item" id="822366c6_938"><p id="822366c6_939">Points to a function that takes void pointers as parameters, allowing for more flexibility in argument types.</p></li><li class="list__item" id="822366c6_940"><p id="822366c6_941">Example:</p><div class="code-block" data-lang="c"         >
void (*ptr)(void *); // Pointer to a function taking a void pointer as a parameter
</div></li></ul></li><li class="list__item" id="822366c6_943"><p id="822366c6_944"><span class="control" id="822366c6_945">Array of Function Pointers:</span></p><ul class="list _ul" id="822366c6_946"><li class="list__item" id="822366c6_947"><p id="822366c6_948">Allows you to create an array of function pointers.</p></li><li class="list__item" id="822366c6_949"><p id="822366c6_950">Example:</p><div class="code-block" data-lang="c"         >
void (*ptrArray[3])(); // Array of function pointers, each taking no parameters
</div></li></ul></li><li class="list__item" id="822366c6_952"><p id="822366c6_953"><span class="control" id="822366c6_954">Function Pointer as a Parameter:</span></p><ul class="list _ul" id="822366c6_955"><li class="list__item" id="822366c6_956"><p id="822366c6_957">Allows passing a function pointer as a parameter to another function.</p></li><li class="list__item" id="822366c6_958"><p id="822366c6_959">Example:</p><div class="code-block" data-lang="c"         >
void operate(int (*operation)(int, int), int a, int b);
</div></li></ul></li><li class="list__item" id="822366c6_961"><p id="822366c6_962"><span class="control" id="822366c6_963">Function Pointer as a Return Type:</span></p><ul class="list _ul" id="822366c6_964"><li class="list__item" id="822366c6_965"><p id="822366c6_966">Allows a function to return a function pointer.</p></li><li class="list__item" id="822366c6_967"><p id="822366c6_968">Example:</p><div class="code-block" data-lang="c"         >
void (*getOperation())(int, int);
</div></li></ul></li><li class="list__item" id="822366c6_970"><p id="822366c6_971"><span class="control" id="822366c6_972">Callback Functions:</span></p><ul class="list _ul" id="822366c6_973"><li class="list__item" id="822366c6_974"><p id="822366c6_975">Often used to implement callback mechanisms, where a function accepts a function pointer as an argument to customize behavior.</p></li><li class="list__item" id="822366c6_976"><p id="822366c6_977">Example:</p><div class="code-block" data-lang="c"         >
void processArray(int arr[], int size, int (*callback)(int));
</div></li></ul></li><li class="list__item" id="822366c6_979"><p id="822366c6_980"><span class="control" id="822366c6_981">Generic Function Pointers:</span></p><ul class="list _ul" id="822366c6_982"><li class="list__item" id="822366c6_983"><p id="822366c6_984">Uses void pointers to create generic function pointers that can point to functions with various signatures.</p></li><li class="list__item" id="822366c6_985"><p id="822366c6_986">Example:</p><div class="code-block" data-lang="c"         >
void (*genericPtr)(void *); // Generic function pointer
</div></li></ul></li></ol><p id="822366c6_988">These are just a few examples of the different types of function pointers in C. The type of function pointer you use depends on the requirements of your program and the level of flexibility and generality you need.</p></section><section class="chapter"><h2 id="2-simple-function-pointer" data-toc="2-simple-function-pointer"   >2. Simple Function Pointer</h2><p id="822366c6_989">A simple function pointer in C is a pointer that points to a function with a specific signature. It allows you to call the function indirectly through the pointer. Here's an example to illustrate the concept:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Function with the same signature as the function pointer
int add(int a, int b) {
    return a + b;
}

int main() {
    // Declare a function pointer named ptr that points to a function taking two ints and returning an int
    int (*ptr)(int, int);

    // Assign the address of the add function to the pointer
    ptr = add;

    // Call the function indirectly through the pointer
    int result = ptr(3, 4);

    // Print the result
    printf(&quot;Result: %d\n&quot;, result);

    return 0;
}
</div><p id="822366c6_991">In this example:</p><ol class="list _decimal" id="822366c6_992" type="1"><li class="list__item" id="822366c6_993"><p>The <code class="code" id="822366c6_994">add</code> function takes two integers and returns their sum.</p></li><li class="list__item" id="822366c6_995"><p>We declare a function pointer named <code class="code" id="822366c6_996">ptr</code> using the syntax <code class="code" id="822366c6_997">int (*ptr)(int, int);</code>. This specifies that <code class="code" id="822366c6_998">ptr</code> is a pointer to a function taking two <code class="code" id="822366c6_999">int</code> parameters and returning an <code class="code" id="822366c6_1000">int</code>.</p></li><li class="list__item" id="822366c6_1001"><p>We assign the address of the <code class="code" id="822366c6_1002">add</code> function to the <code class="code" id="822366c6_1003">ptr</code> pointer using <code class="code" id="822366c6_1004">ptr = add;</code>.</p></li><li class="list__item" id="822366c6_1005"><p>We call the function indirectly through the pointer with <code class="code" id="822366c6_1006">int result = ptr(3, 4);</code>.</p></li><li class="list__item" id="822366c6_1007"><p>Finally, we print the result.</p></li></ol><p id="822366c6_1008">This allows for more dynamic behavior in your code. For example, you could change the function pointer to point to a different function with the same signature, and the code would still work without modification. It is often used in scenarios where you want to switch between different functions at runtime or pass functions as arguments to other functions.</p></section><section class="chapter"><h2 id="3-function-pointer-without-parameters" data-toc="3-function-pointer-without-parameters"   >3. Function Pointer without Parameters</h2><p id="822366c6_1009">A function pointer without parameters is a pointer that points to a function which takes no parameters. This type of function pointer is used when you want to reference a function that doesn't require any input arguments. Here's a simple example:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Function prototype for a function that takes no parameters
void noParameterFunction() {
    printf(&quot;This function takes no parameters.\n&quot;);
}

int main() {
    // Declare a function pointer without parameters
    void (*ptr)();

    // Assign the address of the noParameterFunction to the pointer
    ptr = noParameterFunction;

    // Call the function through the function pointer
    ptr();

    return 0;
}
</div><p id="822366c6_1011">In this example:</p><ul class="list _ul" id="822366c6_1012"><li class="list__item" id="822366c6_1013"><p><code class="code" id="822366c6_1014">noParameterFunction</code> is a function that takes no parameters and prints a message.</p></li><li class="list__item" id="822366c6_1015"><p><code class="code" id="822366c6_1016">ptr</code> is a function pointer declared to point to a function with no parameters.</p></li><li class="list__item" id="822366c6_1017"><p>The address of the <code class="code" id="822366c6_1018">noParameterFunction</code> is assigned to the function pointer <code class="code" id="822366c6_1019">ptr</code>.</p></li><li class="list__item" id="822366c6_1020"><p>The function is then called through the function pointer using the <code class="code" id="822366c6_1021">ptr()</code> syntax.</p></li></ul><p id="822366c6_1022">This allows you to create more flexible code, as you can dynamically switch between different functions that share the same signature (in this case, no parameters). This is particularly useful in scenarios where you may want to provide different behaviors for a particular part of your program without duplicating code.</p></section><section class="chapter"><h2 id="4-function-pointer-with-void-pointer-parameters" data-toc="4-function-pointer-with-void-pointer-parameters"   >4. Function Pointer with Void Pointer Parameters</h2><p id="822366c6_1023">When using a function pointer with void pointer parameters in C, you're allowing the function to accept arguments of any type by using void pointers. This provides flexibility in terms of the data types the function can operate on. Inside the function, you may need to cast the void pointers to the appropriate types before using them. Here's an example to illustrate:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Function that takes two void pointers as parameters
void add(void *a, void *b) {
    // Cast the void pointers to int pointers
    int *num1 = (int *)a;
    int *num2 = (int *)b;

    // Perform addition
    int result = *num1 + *num2;

    // Print the result
    printf(&quot;Sum: %d\n&quot;, result);
}

// Function that takes two void pointers as parameters
void concatenate(void *str1, void *str2) {
    // Cast the void pointers to char pointers
    char *s1 = (char *)str1;
    char *s2 = (char *)str2;

    // Concatenate strings
    printf(&quot;Concatenated String: %s%s\n&quot;, s1, s2);
}

int main() {
    int num1 = 10, num2 = 20;
    char str1[] = &quot;Hello, &quot;;
    char str2[] = &quot;world!&quot;;

    // Declare function pointers
    void (*addPtr)(void *, void *);
    void (*concatenatePtr)(void *, void *);

    // Assign function addresses to the pointers
    addPtr = add;
    concatenatePtr = concatenate;

    // Call functions using function pointers
    addPtr(&amp;num1, &amp;num2);  // Passing addresses of integers
    concatenatePtr(str1, str2);  // Passing addresses of strings

    return 0;
}
</div><p id="822366c6_1025">In this example, the <code class="code" id="822366c6_1026">add</code> function and the <code class="code" id="822366c6_1027">concatenate</code> function both take two void pointers as parameters. The <code class="code" id="822366c6_1028">main</code> function demonstrates how to use function pointers (<code class="code" id="822366c6_1029">addPtr</code> and <code class="code" id="822366c6_1030">concatenatePtr</code>) to call these functions with different types of arguments (integers and strings). The key is to cast the void pointers to the appropriate types within the functions.</p><p id="822366c6_1031">This technique is useful when you want a function to be more generic and handle different data types without explicitly specifying them in the function signature. However, it also requires caution and proper type checking to avoid runtime errors due to incorrect type conversions.</p></section><section class="chapter"><h2 id="5-array-of-function-pointers" data-toc="5-array-of-function-pointers"   >5. Array of Function Pointers</h2><p id="822366c6_1032">An array of function pointers in C is a collection of pointers to functions, where each element in the array points to a function with a specific signature. This can be useful when you want to create a table of functions or provide a mechanism for selecting and invoking different functions dynamically. Here's an explanation with examples:</p><section class="chapter"><h3 id="example-1-basic-array-of-function-pointers" data-toc="example-1-basic-array-of-function-pointers"   >Example 1: Basic Array of Function Pointers</h3><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Function prototypes with the same signature
void add(int a, int b);
void subtract(int a, int b);
void multiply(int a, int b);

int main() {
    // Declare an array of function pointers
    void (*operation[3])(int, int) = {add, subtract, multiply};

    // Invoke functions using the array
    operation[0](5, 3);  // Calls add(5, 3)
    operation[1](8, 2);  // Calls subtract(8, 2)
    operation[2](4, 6);  // Calls multiply(4, 6)

    return 0;
}

// Function definitions
void add(int a, int b) {
    printf(&quot;Addition: %d\n&quot;, a + b);
}

void subtract(int a, int b) {
    printf(&quot;Subtraction: %d\n&quot;, a - b);
}

void multiply(int a, int b) {
    printf(&quot;Multiplication: %d\n&quot;, a * b);
}
</div><p id="822366c6_1034">In this example, the <code class="code" id="822366c6_1035">operation</code> array holds three function pointers, each pointing to a different function with the same signature. The <code class="code" id="822366c6_1036">main</code> function then demonstrates how to invoke these functions using the array.</p></section><section class="chapter"><h3 id="example-2-array-of-function-pointers-with-generic-signature" data-toc="example-2-array-of-function-pointers-with-generic-signature"   >Example 2: Array of Function Pointers with Generic Signature</h3><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Generic function prototype
typedef void (*OperationFunc)(int, int);

// Functions with different signatures
void add(int a, int b);
void subtract(int a, int b);
void multiply(int a, int b);

int main() {
    // Declare an array of function pointers with a generic signature
    OperationFunc operation[3] = {add, subtract, multiply};

    // Invoke functions using the array
    operation[0](5, 3);  // Calls add(5, 3)
    operation[1](8, 2);  // Calls subtract(8, 2)
    operation[2](4, 6);  // Calls multiply(4, 6)

    return 0;
}

// Function definitions
void add(int a, int b) {
    printf(&quot;Addition: %d\n&quot;, a + b);
}

void subtract(int a, int b) {
    printf(&quot;Subtraction: %d\n&quot;, a - b);
}

void multiply(int a, int b) {
    printf(&quot;Multiplication: %d\n&quot;, a * b);
}
</div><p id="822366c6_1038">In this example, a <code class="code" id="822366c6_1039">typedef</code> is used to define a generic function pointer type (<code class="code" id="822366c6_1040">OperationFunc</code>). The array of function pointers is then declared using this type, allowing for functions with different signatures to be stored in the array while still enforcing a consistent function pointer type.</p><p id="822366c6_1041">Arrays of function pointers are powerful constructs that can be utilized for implementing strategies, state machines, and other scenarios where dynamic selection of functions is needed.</p></section></section><section class="chapter"><h2 id="6-function-pointer-as-a-parameter" data-toc="6-function-pointer-as-a-parameter"   >6. Function Pointer as a Parameter</h2><p id="822366c6_1042">Function pointers as parameters are a powerful feature in C, allowing you to pass functions as arguments to other functions. This enables you to create more flexible and reusable code. Here's an explanation along with an example:</p><section class="chapter"><h3 id="function-pointer-as-a-parameter" data-toc="function-pointer-as-a-parameter"   >Function Pointer as a Parameter:</h3><p id="822366c6_1043">When you pass a function pointer as a parameter to another function, you are essentially allowing the calling function to execute a function of the specified type. This is particularly useful for creating generic or customizable functions that can adapt their behavior based on the function provided as an argument.</p></section><section class="chapter"><h3 id="example" data-toc="example"   >Example:</h3><p id="822366c6_1044">Let's say you want to implement a generic utility function that performs an operation on two integers. Instead of hardcoding the operation within the utility function, you can pass a function pointer to it, allowing the caller to define the operation dynamically.</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Define function pointers for different operations
typedef int (*Operation)(int, int);

// Utility function that takes two integers and a function pointer
int operate(int a, int b, Operation op) {
    return op(a, b);
}

// Example operations that match the Operation signature
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    int result;

    // Use operate function with different operations
    result = operate(5, 3, add);
    printf(&quot;Addition: %d\n&quot;, result);

    result = operate(5, 3, subtract);
    printf(&quot;Subtraction: %d\n&quot;, result);

    result = operate(5, 3, multiply);
    printf(&quot;Multiplication: %d\n&quot;, result);

    return 0;
}
</div><p id="822366c6_1046">In this example:</p><ul class="list _ul" id="822366c6_1047"><li class="list__item" id="822366c6_1048"><p>We define a function pointer type <code class="code" id="822366c6_1049">Operation</code> that takes two integers and returns an integer.</p></li><li class="list__item" id="822366c6_1050"><p>The <code class="code" id="822366c6_1051">operate</code> function takes two integers and a function pointer of type <code class="code" id="822366c6_1052">Operation</code>.</p></li><li class="list__item" id="822366c6_1053"><p>The <code class="code" id="822366c6_1054">main</code> function demonstrates using the <code class="code" id="822366c6_1055">operate</code> function with different operations (<code class="code" id="822366c6_1056">add</code>, <code class="code" id="822366c6_1057">subtract</code>, and <code class="code" id="822366c6_1058">multiply</code>).</p></li></ul><p id="822366c6_1059">By passing different operation functions as function pointers to the <code class="code" id="822366c6_1060">operate</code> function, you can perform various operations without modifying the <code class="code" id="822366c6_1061">operate</code> function itself. This illustrates the power of function pointers as parameters in creating more generic and flexible code.</p></section></section><section class="chapter"><h2 id="7-function-pointer-as-a-return-type" data-toc="7-function-pointer-as-a-return-type"   >7. Function Pointer as a Return Type</h2><p id="822366c6_1062">A function pointer as a return type allows a function to return another function pointer. This can be useful in scenarios where the behavior of a program needs to be determined at runtime or when you want to encapsulate certain functionality in a modular way. Here's an example to illustrate this concept:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Function prototype for a function that takes two integers and returns an integer
typedef int (*OperationFunc)(int, int);

// Function prototypes for different operations
int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);

// Function that returns a function pointer based on the specified operation
OperationFunc getOperation(char operationType);

int main() {
    int a = 10, b = 5;

    // Obtain function pointers for different operations
    OperationFunc addFunc = getOperation('+');
    OperationFunc subtractFunc = getOperation('-');
    OperationFunc multiplyFunc = getOperation('*');

    // Perform operations using the obtained function pointers
    printf(&quot;Result of %d + %d = %d\n&quot;, a, b, addFunc(a, b));
    printf(&quot;Result of %d - %d = %d\n&quot;, a, b, subtractFunc(a, b));
    printf(&quot;Result of %d * %d = %d\n&quot;, a, b, multiplyFunc(a, b));

    return 0;
}

// Function that returns a function pointer based on the specified operation
OperationFunc getOperation(char operationType) {
    switch (operationType) {
        case '+':
            return add;
        case '-':
            return subtract;
        case '*':
            return multiply;
        default:
            // Handle unsupported operation or return a default operation
            fprintf(stderr, &quot;Unsupported operation: %c\n&quot;, operationType);
            return add; // Returning addition as a default operation
    }
}

// Implementation of different operations
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}
</div><p id="822366c6_1064">In this example, we have three functions (<code class="code" id="822366c6_1065">add</code>, <code class="code" id="822366c6_1066">subtract</code>, and <code class="code" id="822366c6_1067">multiply</code>) that perform different operations. The <code class="code" id="822366c6_1068">getOperation</code> function takes a character representing the desired operation type and returns the corresponding function pointer. The <code class="code" id="822366c6_1069">main</code> function then uses these function pointers to perform operations on two integers.</p><p id="822366c6_1070">This approach allows for dynamic selection of operations at runtime, making the code more flexible and modular. Depending on the situation, you can easily extend the functionality by adding more operations and updating the <code class="code" id="822366c6_1071">getOperation</code> function.</p></section><section class="chapter"><h2 id="8-callback-functions" data-toc="8-callback-functions"   >8. Callback Functions</h2><p id="822366c6_1072">Callback functions in C are functions that are passed as arguments to other functions. The purpose of using callback functions is to allow a program to specify customizable behavior at runtime. In other words, a function can take a callback function as an argument, and then, during its execution, it calls back the provided function to perform certain actions.</p><p id="822366c6_1073">Here's a simple example to illustrate the concept of callback functions:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Callback function type definition
typedef void (*CallbackFunction)(int);

// Function that takes a callback function as an argument
void performOperation(int x, CallbackFunction callback) {
    printf(&quot;Performing operation on %d\n&quot;, x);
    
    // Call the provided callback function
    callback(x);
}

// Callback function 1
void squareCallback(int x) {
    printf(&quot;Square: %d\n&quot;, x * x);
}

// Callback function 2
void doubleCallback(int x) {
    printf(&quot;Double: %d\n&quot;, 2 * x);
}

int main() {
    // Example 1: Using squareCallback as a callback
    performOperation(5, squareCallback);

    // Example 2: Using doubleCallback as a callback
    performOperation(7, doubleCallback);

    return 0;
}
</div><p id="822366c6_1075">In this example, we have a <code class="code" id="822366c6_1076">performOperation</code> function that takes an integer <code class="code" id="822366c6_1077">x</code> and a callback function (<code class="code" id="822366c6_1078">CallbackFunction</code>). The <code class="code" id="822366c6_1079">performOperation</code> function prints a message and then calls the provided callback function with the input <code class="code" id="822366c6_1080">x</code>. We've defined two callback functions, <code class="code" id="822366c6_1081">squareCallback</code> and <code class="code" id="822366c6_1082">doubleCallback</code>, each performing a different operation on the input value.</p><p id="822366c6_1083">In the <code class="code" id="822366c6_1084">main</code> function, we demonstrate how to use the <code class="code" id="822366c6_1085">performOperation</code> function with different callback functions. When calling <code class="code" id="822366c6_1086">performOperation</code>, we pass the desired callback function as an argument.</p><p id="822366c6_1087">This pattern is commonly used in libraries and frameworks where the library provides a set of operations, and the user can customize the behavior by providing their own callback functions.</p><p id="822366c6_1088">Callback functions provide a powerful mechanism for creating flexible and customizable code, enabling users to extend or modify the behavior of functions without modifying their source code.</p></section><section class="chapter"><h2 id="9-generic-function-pointers" data-toc="9-generic-function-pointers"   >9. Generic Function Pointers</h2><p id="822366c6_1089">Generic function pointers in C use <code class="code" id="822366c6_1090">void</code> pointers to create a type-agnostic mechanism for pointing to functions with different signatures. This allows for a more flexible approach when dealing with functions that may have varying argument types or return types. Here's an example to illustrate generic function pointers:</p><div class="code-block" data-lang="c"         >
#include &lt;stdio.h&gt;

// Generic function pointer type using void pointers
typedef void (*GenericFunctionPointer)(void *);

// Example functions with different signatures
void printInteger(void *data) {
    int *intPtr = (int *)data;
    printf(&quot;Integer value: %d\n&quot;, *intPtr);
}

void printDouble(void *data) {
    double *doublePtr = (double *)data;
    printf(&quot;Double value: %lf\n&quot;, *doublePtr);
}

void printString(void *data) {
    char *str = (char *)data;
    printf(&quot;String: %s\n&quot;, str);
}

int main() {
    // Using generic function pointer to point to functions with different signatures
    GenericFunctionPointer genericPtr;

    int integerValue = 42;
    double doubleValue = 3.14;
    char stringValue[] = &quot;Hello, World!&quot;;

    // Pointing to functions with different signatures
    genericPtr = printInteger;
    genericPtr(&amp;integerValue);

    genericPtr = printDouble;
    genericPtr(&amp;doubleValue);

    genericPtr = printString;
    genericPtr(stringValue);

    return 0;
}
</div><p id="822366c6_1092">In this example, we define a <code class="code" id="822366c6_1093">GenericFunctionPointer</code> type using <code class="code" id="822366c6_1094">typedef</code>. This type is a function pointer that takes a <code class="code" id="822366c6_1095">void*</code> as its parameter. The functions <code class="code" id="822366c6_1096">printInteger</code>, <code class="code" id="822366c6_1097">printDouble</code>, and <code class="code" id="822366c6_1098">printString</code> have different signatures, but they all match the signature expected by <code class="code" id="822366c6_1099">GenericFunctionPointer</code>. The <code class="code" id="822366c6_1100">main</code> function demonstrates how to use the generic function pointer to call these functions with different types of arguments.</p><p id="822366c6_1101">Note that using generic function pointers comes with a trade-off in terms of type safety, as the compiler cannot enforce type correctness during the function pointer assignments. Therefore, it is crucial to ensure proper type casting when working with the data inside the functions pointed to by generic function pointers.</p></section><div class="last-modified"> Last modified: 22 January 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="error-handling.html">Error handling</a>   <a class="navigation-links__next" href="preprocessor-directives.html">Preprocessor directives</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b205/app.js"></script></body></html>